# ğŸ’³ Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹ Ğ² LawerApp Telegram Mini App

## ğŸ“‹ ĞĞ±Ğ·Ğ¾Ñ€ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ½Ğ¾Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹

**LawerApp** Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ Ğ²ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ñ‹Ğµ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸ Telegram Ğ´Ğ»Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹, Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ Telegram Stars, Ğ±Ğ°Ğ½ĞºĞ¾Ğ²ÑĞºĞ¸Ğµ ĞºĞ°Ñ€Ñ‚Ñ‹ Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ñ‹ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹. Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ñ‹Ğµ Ğ¸ ÑƒĞ´Ğ¾Ğ±Ğ½Ñ‹Ğµ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ğ¸Ğ¸ Ğ¿Ñ€ÑĞ¼Ğ¾ Ğ² Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸.

---

## ğŸ¯ ĞŸĞ»Ğ°Ñ‚ĞµĞ¶Ğ½Ğ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°

### **1. Ğ¡Ğ¿Ğ¾ÑĞ¾Ğ±Ñ‹ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ (Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ² Ğ Ğ¤)**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Payment Methods (Russia)                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Telegram      â”‚  â”‚   Bank Cards    â”‚  â”‚   SBP       â”‚  â”‚
â”‚  â”‚   Stars         â”‚  â”‚   (Visa, MC,    â”‚  â”‚   (Fast     â”‚  â”‚
â”‚  â”‚   (Primary)     â”‚  â”‚   ĞœĞ˜Ğ )          â”‚  â”‚   Payments) â”‚  â”‚
â”‚  â”‚                 â”‚  â”‚   (Ğ®Kassa)      â”‚  â”‚             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Ğ®Money        â”‚  â”‚   QIWI          â”‚  â”‚   Bank      â”‚  â”‚
â”‚  â”‚   (Ğ¯Ğ½Ğ´ĞµĞºÑ.      â”‚  â”‚   (Popular      â”‚  â”‚   Transfers â”‚  â”‚
â”‚  â”‚   Ğ”ĞµĞ½ÑŒĞ³Ğ¸)       â”‚  â”‚   in Russia)    â”‚  â”‚   (Corporate)â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ ĞĞ•Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞĞ« Ğ’ Ğ Ğ¤:
- Apple Pay, Google Pay (Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹)
- PayPal (Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½)
- Stripe (Ñ‡Ğ°ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½)
```

### **2. Ğ¢Ğ°Ñ€Ğ¸Ñ„Ğ½Ñ‹Ğµ Ğ¿Ğ»Ğ°Ğ½Ñ‹**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Subscription Plans                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Free Tier     â”‚  â”‚   Premium       â”‚  â”‚   Business  â”‚  â”‚
â”‚  â”‚   â‚½0/Ğ¼ĞµÑÑÑ†      â”‚  â”‚   â‚½990/Ğ¼ĞµÑÑÑ†    â”‚  â”‚   â‚½2990/Ğ¼ĞµÑÑÑ†â”‚  â”‚
â”‚  â”‚   â€¢ 3 ÑĞ¿Ğ¾Ñ€Ğ°     â”‚  â”‚   â€¢ Unlimited   â”‚  â”‚   â€¢ All     â”‚  â”‚
â”‚  â”‚   â€¢ Basic AI    â”‚  â”‚   â€¢ Advanced AI â”‚  â”‚   â€¢ Team    â”‚  â”‚
â”‚  â”‚   â€¢ Email       â”‚  â”‚   â€¢ Priority    â”‚  â”‚   â€¢ API     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Student       â”‚  â”‚   Pay-per-use   â”‚  â”‚   Custom    â”‚  â”‚
â”‚  â”‚   â‚½490/Ğ¼ĞµÑÑÑ†    â”‚  â”‚   â‚½99/Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚  â”‚  â”‚   Enterpriseâ”‚  â”‚
â”‚  â”‚   â€¢ 10 ÑĞ¿Ğ¾Ñ€Ğ¾Ğ²   â”‚  â”‚   â€¢ No limits   â”‚  â”‚   â€¢ Contact â”‚  â”‚
â”‚  â”‚   â€¢ Student ID  â”‚  â”‚   â€¢ Pay as you  â”‚  â”‚   â€¢ Custom  â”‚  â”‚
â”‚  â”‚   â€¢ 50% discountâ”‚  â”‚   â€¢ go          â”‚  â”‚   â€¢ pricing â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ› ï¸ Ğ¢ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ

### **1. Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹**

```bash
# ĞŸĞ»Ğ°Ñ‚ĞµĞ¶Ğ½Ñ‹Ğµ ÑĞµÑ€Ğ²Ğ¸ÑÑ‹
npm install stripe
npm install @stripe/stripe-js

# Ğ£Ñ‚Ğ¸Ğ»Ğ¸Ñ‚Ñ‹
npm install uuid
npm install -D @types/uuid
```

### **2. Telegram Stars Integration**

#### **Telegram Stars Service**
```typescript
// src/lib/payments/telegram-stars-service.ts
import { WebApp } from '@twa-dev/sdk';

export class TelegramStarsService {
  private webApp: typeof WebApp;
  
  constructor() {
    this.webApp = WebApp;
  }
  
  async createPayment(
    amount: number,
    description: string,
    payload?: string
  ): Promise<PaymentResult> {
    try {
      // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¸Ğ½Ğ²Ğ¾Ğ¹Ñ Ñ‡ĞµÑ€ĞµĞ· Telegram Bot API
      const invoice = await this.createInvoice(amount, description, payload);
      
      // ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ½ÑƒÑ Ñ„Ğ¾Ñ€Ğ¼Ñƒ
      const result = await this.showInvoice(invoice);
      
      return {
        success: result.status === 'paid',
        transactionId: result.transaction_id,
        amount,
        currency: 'XTR', // Telegram Stars
        timestamp: new Date(),
      };
    } catch (error) {
      console.error('Telegram Stars payment error:', error);
      throw new Error('Failed to process Telegram Stars payment');
    }
  }
  
  private async createInvoice(
    amount: number,
    description: string,
    payload?: string
  ): Promise<any> {
    const response = await fetch('/api/payments/create-invoice', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        amount,
        description,
        payload,
        currency: 'XTR',
      }),
    });
    
    if (!response.ok) {
      throw new Error('Failed to create invoice');
    }
    
    return await response.json();
  }
  
  private async showInvoice(invoice: any): Promise<any> {
    return new Promise((resolve, reject) => {
      this.webApp.showInvoice(invoice, (result) => {
        if (result.status === 'paid') {
          resolve(result);
        } else {
          reject(new Error('Payment was not completed'));
        }
      });
    });
  }
  
  async checkPaymentStatus(transactionId: string): Promise<PaymentStatus> {
    try {
      const response = await fetch(`/api/payments/status/${transactionId}`);
      const data = await response.json();
      
      return {
        status: data.status,
        amount: data.amount,
        currency: data.currency,
        timestamp: data.timestamp,
      };
    } catch (error) {
      console.error('Payment status check error:', error);
      throw new Error('Failed to check payment status');
    }
  }
}

interface PaymentResult {
  success: boolean;
  transactionId: string;
  amount: number;
  currency: string;
  timestamp: Date;
}

interface PaymentStatus {
  status: 'pending' | 'paid' | 'failed' | 'cancelled';
  amount: number;
  currency: string;
  timestamp: string;
}
```

### **3. Stripe Integration (Ğ´Ğ»Ñ Ğ±Ğ°Ğ½ĞºĞ¾Ğ²ÑĞºĞ¸Ñ… ĞºĞ°Ñ€Ñ‚)**

#### **Stripe Service**
```typescript
// src/lib/payments/stripe-service.ts
import Stripe from 'stripe';

export class StripeService {
  private stripe: Stripe;
  
  constructor() {
    this.stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
      apiVersion: '2023-10-16',
    });
  }
  
  async createPaymentIntent(
    amount: number,
    currency: string = 'rub',
    metadata?: Record<string, string>
  ): Promise<Stripe.PaymentIntent> {
    try {
      const paymentIntent = await this.stripe.paymentIntents.create({
        amount: Math.round(amount * 100), // Convert to kopecks
        currency,
        metadata,
        automatic_payment_methods: {
          enabled: true,
        },
      });
      
      return paymentIntent;
    } catch (error) {
      console.error('Stripe payment intent error:', error);
      throw new Error('Failed to create payment intent');
    }
  }
  
  async confirmPayment(
    paymentIntentId: string,
    paymentMethodId: string
  ): Promise<Stripe.PaymentIntent> {
    try {
      const paymentIntent = await this.stripe.paymentIntents.confirm(
        paymentIntentId,
        {
          payment_method: paymentMethodId,
        }
      );
      
      return paymentIntent;
    } catch (error) {
      console.error('Stripe payment confirmation error:', error);
      throw new Error('Failed to confirm payment');
    }
  }
  
  async createSubscription(
    customerId: string,
    priceId: string,
    metadata?: Record<string, string>
  ): Promise<Stripe.Subscription> {
    try {
      const subscription = await this.stripe.subscriptions.create({
        customer: customerId,
        items: [{ price: priceId }],
        metadata,
        payment_behavior: 'default_incomplete',
        payment_settings: { save_default_payment_method: 'on_subscription' },
        expand: ['latest_invoice.payment_intent'],
      });
      
      return subscription;
    } catch (error) {
      console.error('Stripe subscription error:', error);
      throw new Error('Failed to create subscription');
    }
  }
  
  async cancelSubscription(subscriptionId: string): Promise<Stripe.Subscription> {
    try {
      const subscription = await this.stripe.subscriptions.cancel(subscriptionId);
      return subscription;
    } catch (error) {
      console.error('Stripe subscription cancellation error:', error);
      throw new Error('Failed to cancel subscription');
    }
  }
}
```

### **4. Payment Manager**

#### **Unified Payment Service**
```typescript
// src/lib/payments/payment-manager.ts
import { TelegramStarsService } from './telegram-stars-service';
import { StripeService } from './stripe-service';

export type PaymentMethod = 'telegram_stars' | 'yookassa' | 'sbp' | 'yoomoney' | 'qiwi' | 'bank_transfer';

export interface PaymentRequest {
  amount: number;
  currency: string;
  description: string;
  method: PaymentMethod;
  userId: string;
  metadata?: Record<string, string>;
}

export interface PaymentResponse {
  success: boolean;
  transactionId: string;
  paymentUrl?: string;
  clientSecret?: string;
  error?: string;
}

export class PaymentManager {
  private telegramStarsService: TelegramStarsService;
  private stripeService: StripeService;
  
  constructor() {
    this.telegramStarsService = new TelegramStarsService();
    this.stripeService = new StripeService();
  }
  
  async processPayment(request: PaymentRequest): Promise<PaymentResponse> {
    try {
      switch (request.method) {
        case 'telegram_stars':
          return await this.processTelegramStarsPayment(request);
        case 'yookassa':
          return await this.processYooKassaPayment(request);
        case 'sbp':
          return await this.processSBPPayment(request);
        case 'yoomoney':
          return await this.processYooMoneyPayment(request);
        case 'qiwi':
          return await this.processQIWIPayment(request);
        case 'bank_transfer':
          return await this.processBankTransfer(request);
        default:
          throw new Error(`Unsupported payment method: ${request.method}`);
      }
    } catch (error) {
      console.error('Payment processing error:', error);
      return {
        success: false,
        transactionId: '',
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }
  
  private async processTelegramStarsPayment(
    request: PaymentRequest
  ): Promise<PaymentResponse> {
    const result = await this.telegramStarsService.createPayment(
      request.amount,
      request.description,
      JSON.stringify(request.metadata)
    );
    
    return {
      success: result.success,
      transactionId: result.transactionId,
    };
  }
  
  private async processYooKassaPayment(
    request: PaymentRequest
  ): Promise<PaymentResponse> {
    // Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Ğ®Kassa Ğ´Ğ»Ñ Ğ±Ğ°Ğ½ĞºĞ¾Ğ²ÑĞºĞ¸Ñ… ĞºĞ°Ñ€Ñ‚
    const payment = await this.createYooKassaPayment(request);
    
    return {
      success: true,
      transactionId: payment.id,
      paymentUrl: payment.confirmation_url,
    };
  }
  
  private async processSBPPayment(
    request: PaymentRequest
  ): Promise<PaymentResponse> {
    // Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Ğ¡Ğ‘ĞŸ (Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ñ… Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹)
    const payment = await this.createSBPPayment(request);
    
    return {
      success: true,
      transactionId: payment.id,
      paymentUrl: payment.payment_url,
    };
  }
  
  private async processYooMoneyPayment(
    request: PaymentRequest
  ): Promise<PaymentResponse> {
    // Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Ğ®Money (Ğ¯Ğ½Ğ´ĞµĞºÑ.Ğ”ĞµĞ½ÑŒĞ³Ğ¸)
    const payment = await this.createYooMoneyPayment(request);
    
    return {
      success: true,
      transactionId: payment.id,
      paymentUrl: payment.payment_url,
    };
  }
  
  private async processQIWIPayment(
    request: PaymentRequest
  ): Promise<PaymentResponse> {
    // Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ QIWI
    const payment = await this.createQIWIPayment(request);
    
    return {
      success: true,
      transactionId: payment.id,
      paymentUrl: payment.payment_url,
    };
  }
  
  private async processBankTransfer(
    request: PaymentRequest
  ): Promise<PaymentResponse> {
    // Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ Ñ€ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ñ‹ Ğ´Ğ»Ñ Ğ±Ğ°Ğ½ĞºĞ¾Ğ²ÑĞºĞ¾Ğ³Ğ¾ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ°
    const bankDetails = await this.generateBankDetails(request);
    
    return {
      success: true,
      transactionId: bankDetails.transactionId,
      paymentUrl: bankDetails.paymentUrl,
    };
  }
  
  private async generateBankDetails(request: PaymentRequest) {
    // Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ñ€ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ğ¾Ğ² Ğ´Ğ»Ñ Ğ±Ğ°Ğ½ĞºĞ¾Ğ²ÑĞºĞ¾Ğ³Ğ¾ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ°
    const transactionId = `BT_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    return {
      transactionId,
      paymentUrl: `/payments/bank-transfer/${transactionId}`,
      bankDetails: {
        account: '40702810100000000000',
        bank: 'ĞŸĞĞ Ğ¡Ğ±ĞµÑ€Ğ±Ğ°Ğ½Ğº',
        bic: '044525225',
        purpose: `${request.description} (${transactionId})`,
        amount: request.amount,
      },
    };
  }
}
```

### **5. Subscription Management**

#### **Subscription Service**
```typescript
// src/lib/payments/subscription-service.ts
import { PaymentManager, PaymentMethod } from './payment-manager';

export type SubscriptionPlan = 'free' | 'premium' | 'business' | 'student';

export interface Subscription {
  id: string;
  userId: string;
  plan: SubscriptionPlan;
  status: 'active' | 'cancelled' | 'expired' | 'pending';
  startDate: Date;
  endDate: Date;
  autoRenew: boolean;
  paymentMethod: PaymentMethod;
  transactionId?: string;
}

export class SubscriptionService {
  private paymentManager: PaymentManager;
  
  constructor() {
    this.paymentManager = new PaymentManager();
  }
  
  async createSubscription(
    userId: string,
    plan: SubscriptionPlan,
    paymentMethod: PaymentMethod
  ): Promise<Subscription> {
    try {
      const planDetails = this.getPlanDetails(plan);
      
      const paymentRequest = {
        amount: planDetails.price,
        currency: 'rub',
        description: `ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑĞºĞ° ${planDetails.name}`,
        method: paymentMethod,
        userId,
        metadata: {
          plan,
          type: 'subscription',
        },
      };
      
      const paymentResult = await this.paymentManager.processPayment(paymentRequest);
      
      if (!paymentResult.success) {
        throw new Error('Payment failed');
      }
      
      const subscription: Subscription = {
        id: `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        userId,
        plan,
        status: 'active',
        startDate: new Date(),
        endDate: new Date(Date.now() + planDetails.duration * 24 * 60 * 60 * 1000),
        autoRenew: true,
        paymentMethod,
        transactionId: paymentResult.transactionId,
      };
      
      // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºÑƒ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
      await this.saveSubscription(subscription);
      
      return subscription;
    } catch (error) {
      console.error('Subscription creation error:', error);
      throw new Error('Failed to create subscription');
    }
  }
  
  async cancelSubscription(subscriptionId: string): Promise<void> {
    try {
      const subscription = await this.getSubscription(subscriptionId);
      
      if (!subscription) {
        throw new Error('Subscription not found');
      }
      
      // ĞÑ‚Ğ¼ĞµĞ½ÑĞµĞ¼ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºÑƒ Ğ² Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ½Ğ¾Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ
      if (subscription.paymentMethod === 'stripe' && subscription.transactionId) {
        await this.stripeService.cancelSubscription(subscription.transactionId);
      }
      
      // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
      await this.updateSubscriptionStatus(subscriptionId, 'cancelled');
    } catch (error) {
      console.error('Subscription cancellation error:', error);
      throw new Error('Failed to cancel subscription');
    }
  }
  
  async checkSubscriptionStatus(userId: string): Promise<Subscription | null> {
    try {
      const subscription = await this.getActiveSubscription(userId);
      
      if (!subscription) {
        return null;
      }
      
      // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ½Ğµ Ğ¸ÑÑ‚ĞµĞºĞ»Ğ° Ğ»Ğ¸ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞ°
      if (subscription.endDate < new Date() && subscription.status === 'active') {
        await this.updateSubscriptionStatus(subscription.id, 'expired');
        subscription.status = 'expired';
      }
      
      return subscription;
    } catch (error) {
      console.error('Subscription status check error:', error);
      throw new Error('Failed to check subscription status');
    }
  }
  
  private getPlanDetails(plan: SubscriptionPlan) {
    const plans = {
      free: { name: 'Free', price: 0, duration: 30 },
      premium: { name: 'Premium', price: 990, duration: 30 },
      business: { name: 'Business', price: 2990, duration: 30 },
      student: { name: 'Student', price: 490, duration: 30 },
    };
    
    return plans[plan];
  }
  
  private async saveSubscription(subscription: Subscription): Promise<void> {
    // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    // Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ Ğ²Ğ°ÑˆĞµĞ¹ ORM/Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
  }
  
  private async getSubscription(subscriptionId: string): Promise<Subscription | null> {
    // ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞ¸ Ğ¸Ğ· Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    return null;
  }
  
  private async getActiveSubscription(userId: string): Promise<Subscription | null> {
    // ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ¹ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    return null;
  }
  
  private async updateSubscriptionStatus(
    subscriptionId: string,
    status: Subscription['status']
  ): Promise<void> {
    // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞ¸ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
  }
}
```

### **6. API Endpoints**

#### **Payment API**
```typescript
// src/app/api/payments/create/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { PaymentManager } from '@/lib/payments/payment-manager';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { amount, currency, description, method, userId, metadata } = body;
    
    // Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ²Ñ…Ğ¾Ğ´Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    if (!amount || !description || !method || !userId) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }
    
    const paymentManager = new PaymentManager();
    const result = await paymentManager.processPayment({
      amount,
      currency: currency || 'rub',
      description,
      method,
      userId,
      metadata,
    });
    
    return NextResponse.json(result);
  } catch (error) {
    console.error('Payment creation error:', error);
    return NextResponse.json(
      { error: 'Failed to create payment' },
      { status: 500 }
    );
  }
}
```

#### **Subscription API**
```typescript
// src/app/api/subscriptions/create/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { SubscriptionService } from '@/lib/payments/subscription-service';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { userId, plan, paymentMethod } = body;
    
    if (!userId || !plan || !paymentMethod) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }
    
    const subscriptionService = new SubscriptionService();
    const subscription = await subscriptionService.createSubscription(
      userId,
      plan,
      paymentMethod
    );
    
    return NextResponse.json(subscription);
  } catch (error) {
    console.error('Subscription creation error:', error);
    return NextResponse.json(
      { error: 'Failed to create subscription' },
      { status: 500 }
    );
  }
}
```

### **7. Frontend Components**

#### **Payment Form Component**
```typescript
// src/components/features/payments/PaymentForm.tsx
'use client';

import { useState } from 'react';
import { useTelegram } from '@/lib/telegram/telegram-provider';

interface PaymentFormProps {
  amount: number;
  description: string;
  onSuccess: (transactionId: string) => void;
  onError: (error: string) => void;
}

export const PaymentForm = ({ amount, description, onSuccess, onError }: PaymentFormProps) => {
  const { user } = useTelegram();
  const [selectedMethod, setSelectedMethod] = useState<'telegram_stars' | 'yookassa' | 'sbp' | 'yoomoney' | 'qiwi'>('telegram_stars');
  const [isLoading, setIsLoading] = useState(false);
  
  const handlePayment = async () => {
    if (!user) {
      onError('ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½');
      return;
    }
    
    setIsLoading(true);
    
    try {
      const response = await fetch('/api/payments/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          amount,
          currency: 'rub',
          description,
          method: selectedMethod,
          userId: user.id.toString(),
        }),
      });
      
      const result = await response.json();
      
      if (result.success) {
        onSuccess(result.transactionId);
      } else {
        onError(result.error || 'ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°');
      }
    } catch (error) {
      onError('ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞµÑ‚Ğ¸');
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <div className="space-y-4">
      <div className="bg-telegram-secondary p-4 rounded-lg">
        <h3 className="text-lg font-semibold mb-2">Ğ”ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°</h3>
        <p className="text-sm text-telegram-hint mb-1">{description}</p>
        <p className="text-xl font-bold">{amount} â‚½</p>
      </div>
      
      <div className="space-y-2">
        <h4 className="font-medium">Ğ¡Ğ¿Ğ¾ÑĞ¾Ğ± Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹</h4>
        
        <label className="flex items-center space-x-3 p-3 border border-telegram-secondary rounded-lg cursor-pointer">
          <input
            type="radio"
            name="paymentMethod"
            value="telegram_stars"
            checked={selectedMethod === 'telegram_stars'}
            onChange={(e) => setSelectedMethod(e.target.value as 'telegram_stars')}
            className="text-telegram-button"
          />
          <div>
            <p className="font-medium">Telegram Stars</p>
            <p className="text-sm text-telegram-hint">Ğ’ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ğ°Ñ Ğ²Ğ°Ğ»ÑÑ‚Ğ° Telegram</p>
          </div>
        </label>
        
        <label className="flex items-center space-x-3 p-3 border border-telegram-secondary rounded-lg cursor-pointer">
          <input
            type="radio"
            name="paymentMethod"
            value="yookassa"
            checked={selectedMethod === 'yookassa'}
            onChange={(e) => setSelectedMethod(e.target.value as 'yookassa')}
            className="text-telegram-button"
          />
          <div>
            <p className="font-medium">Ğ‘Ğ°Ğ½ĞºĞ¾Ğ²ÑĞºĞ°Ñ ĞºĞ°Ñ€Ñ‚Ğ°</p>
            <p className="text-sm text-telegram-hint">Visa, MasterCard, ĞœĞ˜Ğ  (Ğ®Kassa)</p>
          </div>
        </label>
        
        <label className="flex items-center space-x-3 p-3 border border-telegram-secondary rounded-lg cursor-pointer">
          <input
            type="radio"
            name="paymentMethod"
            value="sbp"
            checked={selectedMethod === 'sbp'}
            onChange={(e) => setSelectedMethod(e.target.value as 'sbp')}
            className="text-telegram-button"
          />
          <div>
            <p className="font-medium">Ğ¡Ğ‘ĞŸ</p>
            <p className="text-sm text-telegram-hint">Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ñ… Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹</p>
          </div>
        </label>
        
        <label className="flex items-center space-x-3 p-3 border border-telegram-secondary rounded-lg cursor-pointer">
          <input
            type="radio"
            name="paymentMethod"
            value="yoomoney"
            checked={selectedMethod === 'yoomoney'}
            onChange={(e) => setSelectedMethod(e.target.value as 'yoomoney')}
            className="text-telegram-button"
          />
          <div>
            <p className="font-medium">Ğ®Money</p>
            <p className="text-sm text-telegram-hint">Ğ¯Ğ½Ğ´ĞµĞºÑ.Ğ”ĞµĞ½ÑŒĞ³Ğ¸</p>
          </div>
        </label>
        
        <label className="flex items-center space-x-3 p-3 border border-telegram-secondary rounded-lg cursor-pointer">
          <input
            type="radio"
            name="paymentMethod"
            value="qiwi"
            checked={selectedMethod === 'qiwi'}
            onChange={(e) => setSelectedMethod(e.target.value as 'qiwi')}
            className="text-telegram-button"
          />
          <div>
            <p className="font-medium">QIWI</p>
            <p className="text-sm text-telegram-hint">ĞŸĞ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ñ‹Ğ¹ Ğ² Ğ Ğ¾ÑÑĞ¸Ğ¸</p>
          </div>
        </label>
      </div>
      
      <button
        onClick={handlePayment}
        disabled={isLoading}
        className="w-full bg-telegram-button text-telegram-button-text py-3 px-4 rounded-lg font-medium disabled:opacity-50"
      >
        {isLoading ? 'ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°...' : 'ĞĞ¿Ğ»Ğ°Ñ‚Ğ¸Ñ‚ÑŒ'}
      </button>
    </div>
  );
};
```

#### **Subscription Plans Component**
```typescript
// src/components/features/payments/SubscriptionPlans.tsx
'use client';

import { useState } from 'react';
import { useTelegram } from '@/lib/telegram/telegram-provider';

interface Plan {
  id: string;
  name: string;
  price: number;
  features: string[];
  popular?: boolean;
}

const plans: Plan[] = [
  {
    id: 'free',
    name: 'Free',
    price: 0,
    features: [
      '3 ÑĞ¿Ğ¾Ñ€Ğ° Ğ² Ğ¼ĞµÑÑÑ†',
      'Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ AI ĞºĞ¾Ğ½ÑÑƒĞ»ÑŒÑ‚Ğ°Ñ†Ğ¸Ğ¸',
      'Email Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ°',
    ],
  },
  {
    id: 'premium',
    name: 'Premium',
    price: 990,
    features: [
      'ĞĞµĞ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ½Ñ‹Ğµ ÑĞ¿Ğ¾Ñ€Ñ‹',
      'ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğµ AI ĞºĞ¾Ğ½ÑÑƒĞ»ÑŒÑ‚Ğ°Ñ†Ğ¸Ğ¸',
      'Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²',
      'ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚Ğ½Ğ°Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ°',
      'Telegram ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ',
    ],
    popular: true,
  },
  {
    id: 'business',
    name: 'Business',
    price: 2990,
    features: [
      'Ğ’ÑĞµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Premium',
      'ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ½Ğ°Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°',
      'ĞĞ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ¸ Ğ¾Ñ‚Ñ‡ĞµÑ‚Ñ‹',
      'API Ğ´Ğ¾ÑÑ‚ÑƒĞ¿',
      'ĞŸĞµÑ€ÑĞ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¼ĞµĞ½ĞµĞ´Ğ¶ĞµÑ€',
    ],
  },
];

export const SubscriptionPlans = () => {
  const { user } = useTelegram();
  const [selectedPlan, setSelectedPlan] = useState<string>('premium');
  const [isLoading, setIsLoading] = useState(false);
  
  const handleSubscribe = async (planId: string) => {
    if (!user) return;
    
    setIsLoading(true);
    
    try {
      const response = await fetch('/api/subscriptions/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          userId: user.id.toString(),
          plan: planId,
          paymentMethod: 'telegram_stars',
        }),
      });
      
      const result = await response.json();
      
      if (result.success) {
        // ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
        console.log('Subscription created:', result);
      } else {
        console.error('Subscription error:', result.error);
      }
    } catch (error) {
      console.error('Subscription error:', error);
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-bold text-center">Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ°Ñ€Ğ¸Ñ„</h2>
      
      <div className="grid gap-4">
        {plans.map((plan) => (
          <div
            key={plan.id}
            className={`relative p-6 rounded-lg border-2 ${
              plan.popular
                ? 'border-telegram-button bg-telegram-button/5'
                : 'border-telegram-secondary bg-telegram-secondary/20'
            }`}
          >
            {plan.popular && (
              <div className="absolute -top-3 left-1/2 transform -translate-x-1/2">
                <span className="bg-telegram-button text-telegram-button-text px-3 py-1 rounded-full text-sm font-medium">
                  ĞŸĞ¾Ğ¿ÑƒĞ»ÑÑ€Ğ½Ñ‹Ğ¹
                </span>
              </div>
            )}
            
            <div className="text-center mb-4">
              <h3 className="text-xl font-bold">{plan.name}</h3>
              <div className="mt-2">
                <span className="text-3xl font-bold">{plan.price}</span>
                <span className="text-telegram-hint"> â‚½/Ğ¼ĞµÑÑÑ†</span>
              </div>
            </div>
            
            <ul className="space-y-2 mb-6">
              {plan.features.map((feature, index) => (
                <li key={index} className="flex items-center space-x-2">
                  <span className="text-telegram-button">âœ“</span>
                  <span className="text-sm">{feature}</span>
                </li>
              ))}
            </ul>
            
            <button
              onClick={() => handleSubscribe(plan.id)}
              disabled={isLoading || plan.id === 'free'}
              className={`w-full py-3 px-4 rounded-lg font-medium ${
                plan.id === 'free'
                  ? 'bg-telegram-secondary text-telegram-hint cursor-not-allowed'
                  : 'bg-telegram-button text-telegram-button-text'
              }`}
            >
              {plan.id === 'free' ? 'Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ¿Ğ»Ğ°Ğ½' : 'Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¿Ğ»Ğ°Ğ½'}
            </button>
          </div>
        ))}
      </div>
    </div>
  );
};
```

---

## ğŸ“Š ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ¸ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ°

### **1. Payment Analytics**
```typescript
// src/lib/payments/analytics.ts
export class PaymentAnalytics {
  static trackPayment(
    userId: string,
    amount: number,
    method: string,
    success: boolean,
    error?: string
  ) {
    fetch('/api/analytics/payment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId,
        amount,
        method,
        success,
        error,
        timestamp: new Date().toISOString(),
      }),
    });
  }
  
  static trackSubscription(
    userId: string,
    plan: string,
    action: 'created' | 'cancelled' | 'renewed',
    amount?: number
  ) {
    fetch('/api/analytics/subscription', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId,
        plan,
        action,
        amount,
        timestamp: new Date().toISOString(),
      }),
    });
  }
}
```

### **2. Webhook Handlers**

#### **Telegram Webhook**
```typescript
// src/app/api/webhooks/telegram/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°
    if (body.pre_checkout_query) {
      // ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´Ğ°ĞµĞ¼ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶
      return NextResponse.json({ ok: true });
    }
    
    // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°
    if (body.message?.successful_payment) {
      const payment = body.message.successful_payment;
      
      // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞºĞ¸
      await updateSubscriptionStatus(payment.invoice_payload, 'active');
      
      // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
      await sendPaymentConfirmation(body.message.from.id, payment);
    }
    
    return NextResponse.json({ ok: true });
  } catch (error) {
    console.error('Telegram webhook error:', error);
    return NextResponse.json({ error: 'Webhook processing failed' }, { status: 500 });
  }
}
```

#### **Stripe Webhook**
```typescript
// src/app/api/webhooks/stripe/route.ts
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);
const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!;

export async function POST(request: NextRequest) {
  try {
    const body = await request.text();
    const signature = request.headers.get('stripe-signature')!;
    
    const event = stripe.webhooks.constructEvent(body, signature, webhookSecret);
    
    switch (event.type) {
      case 'payment_intent.succeeded':
        await handlePaymentSuccess(event.data.object);
        break;
      case 'invoice.payment_succeeded':
        await handleSubscriptionPayment(event.data.object);
        break;
      case 'customer.subscription.deleted':
        await handleSubscriptionCancellation(event.data.object);
        break;
    }
    
    return NextResponse.json({ received: true });
  } catch (error) {
    console.error('Stripe webhook error:', error);
    return NextResponse.json({ error: 'Webhook processing failed' }, { status: 400 });
  }
}
```

---

## ğŸ”’ Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ

### **1. Payment Validation**
```typescript
// src/lib/payments/validation.ts
import { z } from 'zod';

export const paymentSchema = z.object({
  amount: z.number().min(1).max(1000000),
  currency: z.enum(['rub', 'usd', 'eur']),
  description: z.string().min(1).max(500),
  method: z.enum(['telegram_stars', 'stripe', 'bank_transfer']),
  userId: z.string().uuid(),
});

export const subscriptionSchema = z.object({
  plan: z.enum(['free', 'premium', 'business', 'student']),
  paymentMethod: z.enum(['telegram_stars', 'stripe', 'bank_transfer']),
  userId: z.string().uuid(),
});
```

### **2. Rate Limiting**
```typescript
// src/lib/payments/rate-limiter.ts
export class PaymentRateLimiter {
  private static attempts = new Map<string, number[]>();
  
  static async checkLimit(userId: string, limit: number = 5, windowMs: number = 300000): Promise<boolean> {
    const now = Date.now();
    const userAttempts = this.attempts.get(userId) || [];
    
    // Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ñ‹Ğµ Ğ¿Ğ¾Ğ¿Ñ‹Ñ‚ĞºĞ¸
    const recentAttempts = userAttempts.filter(time => now - time < windowMs);
    
    if (recentAttempts.length >= limit) {
      return false;
    }
    
    // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²ÑƒÑ Ğ¿Ğ¾Ğ¿Ñ‹Ñ‚ĞºÑƒ
    recentAttempts.push(now);
    this.attempts.set(userId, recentAttempts);
    
    return true;
  }
}
```

---

## ğŸ§ª Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

### **1. Unit Tests**
```typescript
// tests/lib/payments/telegram-stars-service.test.ts
import { TelegramStarsService } from '@/lib/payments/telegram-stars-service';

describe('TelegramStarsService', () => {
  let service: TelegramStarsService;
  
  beforeEach(() => {
    service = new TelegramStarsService();
  });
  
  it('should create payment with valid parameters', async () => {
    const result = await service.createPayment(100, 'Test payment');
    
    expect(result.success).toBeDefined();
    expect(result.transactionId).toBeDefined();
    expect(result.amount).toBe(100);
  });
  
  it('should handle payment errors', async () => {
    await expect(service.createPayment(-1, 'Invalid payment')).rejects.toThrow();
  });
});
```

### **2. Integration Tests**
```typescript
// tests/api/payments/create.test.ts
import { POST } from '@/app/api/payments/create/route';
import { NextRequest } from 'next/server';

describe('/api/payments/create', () => {
  it('should create payment with valid data', async () => {
    const request = new NextRequest('http://localhost:3000/api/payments/create', {
      method: 'POST',
      body: JSON.stringify({
        amount: 100,
        currency: 'rub',
        description: 'Test payment',
        method: 'telegram_stars',
        userId: 'test-user-id',
      }),
    });
    
    const response = await POST(request);
    const data = await response.json();
    
    expect(response.status).toBe(200);
    expect(data.success).toBeDefined();
  });
});
```

---

## ğŸ“ˆ ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ

### **1. Caching**
```typescript
// src/lib/payments/cache.ts
import { Redis } from 'ioredis';

export class PaymentCache {
  private redis: Redis;
  
  constructor() {
    this.redis = new Redis(process.env.REDIS_URL!);
  }
  
  async cachePaymentStatus(transactionId: string, status: any, ttl: number = 3600): Promise<void> {
    const key = `payment:status:${transactionId}`;
    await this.redis.setex(key, ttl, JSON.stringify(status));
  }
  
  async getCachedPaymentStatus(transactionId: string): Promise<any | null> {
    const key = `payment:status:${transactionId}`;
    const cached = await this.redis.get(key);
    return cached ? JSON.parse(cached) : null;
  }
}
```

### **2. Retry Logic**
```typescript
// src/lib/payments/retry.ts
export class PaymentRetry {
  static async withRetry<T>(
    operation: () => Promise<T>,
    maxRetries: number = 3,
    delay: number = 1000
  ): Promise<T> {
    let lastError: Error;
    
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        
        if (i < maxRetries - 1) {
          await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
        }
      }
    }
    
    throw lastError!;
  }
}
```

---

## ğŸ¯ Ğ—Ğ°ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ

Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹ Ğ² LawerApp Telegram Mini App Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ğ²Ğ°ĞµÑ‚:

- âœ… **ĞœĞ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ñ‹ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹** - Telegram Stars, Ğ±Ğ°Ğ½ĞºĞ¾Ğ²ÑĞºĞ¸Ğµ ĞºĞ°Ñ€Ñ‚Ñ‹, Ğ±Ğ°Ğ½ĞºĞ¾Ğ²ÑĞºĞ¸Ğµ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ñ‹
- âœ… **Ğ“Ğ¸Ğ±ĞºĞ¸Ğµ Ñ‚Ğ°Ñ€Ğ¸Ñ„Ğ½Ñ‹Ğµ Ğ¿Ğ»Ğ°Ğ½Ñ‹** - Ğ¾Ñ‚ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ´Ğ¾ ĞºĞ¾Ñ€Ğ¿Ğ¾Ñ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ¾Ğ³Ğ¾
- âœ… **Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚ÑŒ** - Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ, rate limiting, webhook Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°
- âœ… **ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³** - Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹ Ğ¸ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞ¾Ğº
- âœ… **ĞœĞ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ** - ĞºÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸ retry Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°

**Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ ÑˆĞ°Ğ³:** ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° webhook'Ğ¾Ğ² Ğ¸ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹! ğŸ’³ğŸš€

---

*Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹ Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ»ĞµĞ½Ğ°: 16 Ğ¾ĞºÑ‚ÑĞ±Ñ€Ñ 2025*  
*Ğ’ĞµÑ€ÑĞ¸Ñ: 1.0*  
*Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: Ğ“Ğ¾Ñ‚Ğ¾Ğ² Ğº Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ âœ…*
