# üîí –†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ LawerApp Telegram Mini App

## üìã –û–±–∑–æ—Ä –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

**LawerApp** –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ –ø—Ä–∞–≤–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, —á—Ç–æ —Ç—Ä–µ–±—É–µ—Ç —Å–æ–±–ª—é–¥–µ–Ω–∏—è –≤—ã—Å–æ—á–∞–π—à–∏—Ö —Å—Ç–∞–Ω–¥–∞—Ä—Ç–æ–≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏. –î–∞–Ω–Ω–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –æ—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞—Ö 2025 –≥–æ–¥–∞ –∏ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è—Ö —Ä–æ—Å—Å–∏–π—Å–∫–æ–≥–æ –∑–∞–∫–æ–Ω–æ–¥–∞—Ç–µ–ª—å—Å—Ç–≤–∞.

---

## üéØ –ü—Ä–∏–Ω—Ü–∏–ø—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

### **1. Zero Trust Architecture**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Zero Trust Model                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   Identity      ‚îÇ  ‚îÇ   Device        ‚îÇ  ‚îÇ   Network   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   Verification  ‚îÇ  ‚îÇ   Trust         ‚îÇ  ‚îÇ   Security  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   (MFA)         ‚îÇ  ‚îÇ   (TLS 1.3)     ‚îÇ  ‚îÇ   (WAF)     ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   Data          ‚îÇ  ‚îÇ   Application   ‚îÇ  ‚îÇ   Workload  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   Protection    ‚îÇ  ‚îÇ   Security      ‚îÇ  ‚îÇ   Security  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   (Encryption)  ‚îÇ  ‚îÇ   (SAST/DAST)   ‚îÇ  ‚îÇ   (CSPM)    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### **2. Defense in Depth**
- **–°–ª–æ–π 1**: –°–µ—Ç–µ–≤–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å (WAF, DDoS protection)
- **–°–ª–æ–π 2**: –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è (OAuth 2.1, OIDC)
- **–°–ª–æ–π 3**: –ó–∞—â–∏—Ç–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (SAST, DAST, IAST)
- **–°–ª–æ–π 4**: –ó–∞—â–∏—Ç–∞ –¥–∞–Ω–Ω—ã—Ö (Encryption at rest/transit)
- **–°–ª–æ–π 5**: –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ —Ä–µ–∞–≥–∏—Ä–æ–≤–∞–Ω–∏–µ (SIEM, SOAR)

---

## üõ°Ô∏è –ó–∞—â–∏—Ç–∞ –¥–∞–Ω–Ω—ã—Ö

### **1. –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö**

#### **Encryption at Rest**
```typescript
// src/lib/security/encryption.ts
import { createCipheriv, createDecipheriv, randomBytes, scrypt } from 'crypto';
import { promisify } from 'util';

const scryptAsync = promisify(scrypt);

export class DataEncryption {
  private static readonly ALGORITHM = 'aes-256-gcm';
  private static readonly KEY_LENGTH = 32;
  private static readonly IV_LENGTH = 16;
  private static readonly TAG_LENGTH = 16;

  static async encrypt(text: string, password: string): Promise<string> {
    const iv = randomBytes(this.IV_LENGTH);
    const key = await this.deriveKey(password, iv);
    const cipher = createCipheriv(this.ALGORITHM, key, iv);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const tag = cipher.getAuthTag();
    
    return `${iv.toString('hex')}:${tag.toString('hex')}:${encrypted}`;
  }

  static async decrypt(encryptedData: string, password: string): Promise<string> {
    const [ivHex, tagHex, encrypted] = encryptedData.split(':');
    const iv = Buffer.from(ivHex, 'hex');
    const tag = Buffer.from(tagHex, 'hex');
    const key = await this.deriveKey(password, iv);
    
    const decipher = createDecipheriv(this.ALGORITHM, key, iv);
    decipher.setAuthTag(tag);
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }

  private static async deriveKey(password: string, salt: Buffer): Promise<Buffer> {
    return (await scryptAsync(password, salt, this.KEY_LENGTH)) as Buffer;
  }
}
```

#### **Encryption in Transit**
```typescript
// src/lib/security/tls.ts
export const TLS_CONFIG = {
  // TLS 1.3 —Ç–æ–ª—å–∫–æ
  minVersion: 'TLSv1.3',
  maxVersion: 'TLSv1.3',
  
  // –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ cipher suites
  ciphers: [
    'TLS_AES_256_GCM_SHA384',
    'TLS_CHACHA20_POLY1305_SHA256',
    'TLS_AES_128_GCM_SHA256'
  ].join(':'),
  
  // HSTS headers
  hsts: {
    maxAge: 31536000, // 1 –≥–æ–¥
    includeSubDomains: true,
    preload: true
  }
};
```

### **2. –ó–∞—â–∏—Ç–∞ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (152-–§–ó)**

#### **Data Classification**
```typescript
// src/lib/security/data-classification.ts
export enum DataClassification {
  PUBLIC = 'public',           // –ü—É–±–ª–∏—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
  INTERNAL = 'internal',       // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ
  CONFIDENTIAL = 'confidential', // –ö–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ
  RESTRICTED = 'restricted'    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
}

export interface DataProtectionPolicy {
  classification: DataClassification;
  retentionPeriod: number; // –¥–Ω–∏
  encryptionRequired: boolean;
  accessLogging: boolean;
  anonymizationRequired: boolean;
}

export const DATA_PROTECTION_POLICIES: Record<string, DataProtectionPolicy> = {
  user_profile: {
    classification: DataClassification.CONFIDENTIAL,
    retentionPeriod: 2555, // 7 –ª–µ—Ç
    encryptionRequired: true,
    accessLogging: true,
    anonymizationRequired: true
  },
  legal_documents: {
    classification: DataClassification.RESTRICTED,
    retentionPeriod: 3650, // 10 –ª–µ—Ç
    encryptionRequired: true,
    accessLogging: true,
    anonymizationRequired: false
  },
  ai_conversations: {
    classification: DataClassification.CONFIDENTIAL,
    retentionPeriod: 365, // 1 –≥–æ–¥
    encryptionRequired: true,
    accessLogging: true,
    anonymizationRequired: true
  }
};
```

#### **Data Anonymization**
```typescript
// src/lib/security/anonymization.ts
export class DataAnonymizer {
  static anonymizeUserData(user: any): any {
    return {
      ...user,
      firstName: this.maskString(user.firstName),
      lastName: this.maskString(user.lastName),
      email: this.maskEmail(user.email),
      phone: this.maskPhone(user.phone),
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–æ–ª—è
      id: user.id,
      createdAt: user.createdAt
    };
  }

  static anonymizeLegalDocument(document: any): any {
    return {
      ...document,
      content: this.maskLegalContent(document.content),
      clientName: this.maskString(document.clientName),
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
      type: document.type,
      createdAt: document.createdAt
    };
  }

  private static maskString(str: string): string {
    if (!str) return '';
    return str.length > 2 
      ? str[0] + '*'.repeat(str.length - 2) + str[str.length - 1]
      : '*'.repeat(str.length);
  }

  private static maskEmail(email: string): string {
    const [local, domain] = email.split('@');
    return `${local[0]}***@${domain}`;
  }

  private static maskPhone(phone: string): string {
    return phone.replace(/(\d{3})\d{3}(\d{2})(\d{2})/, '$1***$2$3');
  }

  private static maskLegalContent(content: string): string {
    // –ú–∞—Å–∫–∏—Ä—É–µ–º –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –ø—Ä–∞–≤–æ–≤—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö
    return content
      .replace(/\b[–ê-–Ø][–∞-—è]+\s[–ê-–Ø][–∞-—è]+\s[–ê-–Ø][–∞-—è]+\b/g, '[–§–ò–û]')
      .replace(/\b\d{4}\s\d{4}\s\d{4}\s\d{4}\b/g, '[–ù–û–ú–ï–† –ö–ê–†–¢–´]')
      .replace(/\b\d{3}-\d{3}-\d{2}-\d{2}\b/g, '[–¢–ï–õ–ï–§–û–ù]');
  }
}
```

---

## üîê –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è

### **1. Multi-Factor Authentication (MFA)**

#### **Telegram-based MFA**
```typescript
// src/lib/auth/telegram-mfa.ts
export class TelegramMFA {
  static async initiateMFA(userId: string): Promise<MFAChallenge> {
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
    const code = this.generateSecureCode();
    const expiresAt = new Date(Date.now() + 5 * 60 * 1000); // 5 –º–∏–Ω—É—Ç
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Redis —Å TTL
    await redis.setex(`mfa:${userId}`, 300, JSON.stringify({
      code,
      attempts: 0,
      expiresAt
    }));
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–¥ —á–µ—Ä–µ–∑ Telegram
    await this.sendTelegramCode(userId, code);
    
    return {
      challengeId: `mfa_${userId}_${Date.now()}`,
      expiresAt,
      method: 'telegram'
    };
  }

  static async verifyMFA(userId: string, code: string): Promise<boolean> {
    const mfaData = await redis.get(`mfa:${userId}`);
    if (!mfaData) return false;
    
    const { code: storedCode, attempts } = JSON.parse(mfaData);
    
    if (attempts >= 3) {
      await redis.del(`mfa:${userId}`);
      throw new Error('Too many attempts');
    }
    
    if (storedCode === code) {
      await redis.del(`mfa:${userId}`);
      return true;
    }
    
    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø–æ–ø—ã—Ç–æ–∫
    await redis.setex(`mfa:${userId}`, 300, JSON.stringify({
      code: storedCode,
      attempts: attempts + 1
    }));
    
    return false;
  }

  private static generateSecureCode(): string {
    return Math.floor(100000 + Math.random() * 900000).toString();
  }
}
```

### **2. OAuth 2.1 + OIDC**

#### **Modern OAuth Implementation**
```typescript
// src/lib/auth/oauth.ts
export class ModernOAuth {
  static async initiateOAuth(provider: 'telegram' | 'yandex'): Promise<OAuthURL> {
    const state = this.generateSecureState();
    const codeVerifier = this.generateCodeVerifier();
    const codeChallenge = await this.generateCodeChallenge(codeVerifier);
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º PKCE –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    await redis.setex(`oauth:${state}`, 600, JSON.stringify({
      codeVerifier,
      provider,
      timestamp: Date.now()
    }));
    
    const authUrl = this.buildAuthUrl(provider, state, codeChallenge);
    
    return { authUrl, state };
  }

  static async handleCallback(
    code: string, 
    state: string, 
    codeVerifier: string
  ): Promise<AuthResult> {
    // –í–∞–ª–∏–¥–∏—Ä—É–µ–º state
    const oauthData = await redis.get(`oauth:${state}`);
    if (!oauthData) {
      throw new Error('Invalid state');
    }
    
    const { provider } = JSON.parse(oauthData);
    
    // –û–±–º–µ–Ω–∏–≤–∞–µ–º –∫–æ–¥ –Ω–∞ —Ç–æ–∫–µ–Ω
    const tokenResponse = await this.exchangeCodeForToken(
      provider, 
      code, 
      codeVerifier
    );
    
    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
    const userInfo = await this.getUserInfo(provider, tokenResponse.access_token);
    
    // –°–æ–∑–¥–∞–µ–º JWT —Ç–æ–∫–µ–Ω
    const jwt = await this.createJWT(userInfo);
    
    return {
      accessToken: jwt,
      refreshToken: tokenResponse.refresh_token,
      user: userInfo
    };
  }

  private static generateSecureState(): string {
    return randomBytes(32).toString('hex');
  }

  private static generateCodeVerifier(): string {
    return randomBytes(32).toString('base64url');
  }

  private static async generateCodeChallenge(verifier: string): Promise<string> {
    const hash = await crypto.subtle.digest('SHA-256', 
      new TextEncoder().encode(verifier)
    );
    return btoa(String.fromCharCode(...new Uint8Array(hash)))
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=/g, '');
  }
}
```

---

## üõ°Ô∏è –ó–∞—â–∏—Ç–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

### **1. Input Validation & Sanitization**

#### **Advanced Input Validation**
```typescript
// src/lib/security/validation.ts
import { z } from 'zod';
import DOMPurify from 'isomorphic-dompurify';

export class SecurityValidator {
  // –°—Ö–µ–º—ã –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö
  static readonly schemas = {
    userInput: z.string()
      .min(1)
      .max(1000)
      .regex(/^[–∞-—è–ê-–Ø—ë–Å\s\d\.,!?\-()]+$/, 'Only Cyrillic characters allowed'),
    
    legalDocument: z.string()
      .min(10)
      .max(50000)
      .refine(this.isValidLegalContent, 'Invalid legal content'),
    
    email: z.string()
      .email()
      .max(254)
      .refine(this.isValidEmail, 'Invalid email format'),
    
    phone: z.string()
      .regex(/^\+7\d{10}$/, 'Invalid Russian phone number')
  };

  static validateAndSanitize(input: any, schema: z.ZodSchema): any {
    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    const validated = schema.parse(input);
    
    // –°–∞–Ω–∏—Ç–∏–∑–∞—Ü–∏—è
    if (typeof validated === 'string') {
      return DOMPurify.sanitize(validated, {
        ALLOWED_TAGS: [],
        ALLOWED_ATTR: []
      });
    }
    
    return validated;
  }

  static async validateFileUpload(file: File): Promise<boolean> {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–∞ —Ñ–∞–π–ª–∞
    const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png'];
    if (!allowedTypes.includes(file.type)) {
      throw new Error('Invalid file type');
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ (–º–∞–∫—Å–∏–º—É–º 10MB)
    if (file.size > 10 * 1024 * 1024) {
      throw new Error('File too large');
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤–∏—Ä—É—Å—ã (–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –∞–Ω—Ç–∏–≤–∏—Ä—É—Å–æ–º)
    const isClean = await this.scanFile(file);
    if (!isClean) {
      throw new Error('File contains malware');
    }
    
    return true;
  }

  private static isValidLegalContent(content: string): boolean {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç–µ–Ω—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—Ä–∞–≤–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
    const legalKeywords = [
      '–¥–æ–≥–æ–≤–æ—Ä', '—Å–æ–≥–ª–∞—à–µ–Ω–∏–µ', '–ø—Ä–µ—Ç–µ–Ω–∑–∏—è', '–∏—Å–∫', '—Å—É–¥',
      '–ø—Ä–∞–≤–∞', '–æ–±—è–∑–∞–Ω–Ω–æ—Å—Ç–∏', '–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å', '–∑–∞–∫–æ–Ω'
    ];
    
    return legalKeywords.some(keyword => 
      content.toLowerCase().includes(keyword)
    );
  }

  private static isValidEmail(email: string): boolean {
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ email
    const domain = email.split('@')[1];
    const suspiciousDomains = ['tempmail.com', '10minutemail.com'];
    
    return !suspiciousDomains.includes(domain);
  }

  private static async scanFile(file: File): Promise<boolean> {
    // –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –∞–Ω—Ç–∏–≤–∏—Ä—É—Å–Ω—ã–º API
    const formData = new FormData();
    formData.append('file', file);
    
    const response = await fetch('/api/security/scan-file', {
      method: 'POST',
      body: formData
    });
    
    const result = await response.json();
    return result.clean;
  }
}
```

### **2. Rate Limiting & DDoS Protection**

#### **Advanced Rate Limiting**
```typescript
// src/lib/security/rate-limiting.ts
export class AdvancedRateLimiter {
  private static readonly limits = {
    // –õ–∏–º–∏—Ç—ã –ø–æ —Ç–∏–ø–∞–º –∑–∞–ø—Ä–æ—Å–æ–≤
    api: { requests: 100, window: 60 * 1000 }, // 100 req/min
    auth: { requests: 5, window: 15 * 60 * 1000 }, // 5 req/15min
    ai: { requests: 10, window: 60 * 1000 }, // 10 req/min
    upload: { requests: 5, window: 60 * 1000 }, // 5 req/min
    payment: { requests: 3, window: 60 * 1000 } // 3 req/min
  };

  static async checkLimit(
    identifier: string, 
    type: keyof typeof AdvancedRateLimiter.limits
  ): Promise<RateLimitResult> {
    const limit = this.limits[type];
    const key = `rate_limit:${type}:${identifier}`;
    
    const current = await redis.incr(key);
    
    if (current === 1) {
      await redis.expire(key, Math.ceil(limit.window / 1000));
    }
    
    const remaining = Math.max(0, limit.requests - current);
    const resetTime = await redis.ttl(key);
    
    return {
      allowed: current <= limit.requests,
      remaining,
      resetTime: Date.now() + (resetTime * 1000),
      retryAfter: current > limit.requests ? resetTime : 0
    };
  }

  static async checkDDoSProtection(ip: string): Promise<boolean> {
    const key = `ddos:${ip}`;
    const requests = await redis.incr(key);
    
    if (requests === 1) {
      await redis.expire(key, 60); // 1 –º–∏–Ω—É—Ç–∞
    }
    
    // –ë–ª–æ–∫–∏—Ä—É–µ–º IP –ø—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ 1000 –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –º–∏–Ω—É—Ç—É
    if (requests > 1000) {
      await redis.setex(`blocked:${ip}`, 3600, '1'); // –ë–ª–æ–∫–∏—Ä—É–µ–º –Ω–∞ —á–∞—Å
      return false;
    }
    
    return true;
  }
}
```

---

## üîç –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —É–≥—Ä–æ–∑

### **1. Security Information and Event Management (SIEM)**

#### **Security Event Logging**
```typescript
// src/lib/security/siem.ts
export class SecuritySIEM {
  static async logSecurityEvent(event: SecurityEvent): Promise<void> {
    const logEntry = {
      timestamp: new Date().toISOString(),
      eventId: this.generateEventId(),
      severity: event.severity,
      category: event.category,
      source: event.source,
      details: event.details,
      userId: event.userId,
      ip: event.ip,
      userAgent: event.userAgent,
      sessionId: event.sessionId
    };
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ SIEM —Å–∏—Å—Ç–µ–º—É
    await this.sendToSIEM(logEntry);
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ª–æ–∫–∞–ª—å–Ω–æ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
    await this.storeLocally(logEntry);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –∞–Ω–æ–º–∞–ª–∏–∏
    await this.checkForAnomalies(logEntry);
  }

  static async detectAnomalies(userId: string): Promise<AnomalyDetection> {
    const recentEvents = await this.getRecentEvents(userId, 24 * 60 * 60 * 1000); // 24 —á–∞—Å–∞
    
    const anomalies = [];
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—É—é –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
    if (this.detectBruteForce(recentEvents)) {
      anomalies.push({
        type: 'brute_force',
        severity: 'high',
        description: 'Multiple failed login attempts detected'
      });
    }
    
    if (this.detectUnusualLocation(recentEvents)) {
      anomalies.push({
        type: 'unusual_location',
        severity: 'medium',
        description: 'Login from unusual geographic location'
      });
    }
    
    if (this.detectDataExfiltration(recentEvents)) {
      anomalies.push({
        type: 'data_exfiltration',
        severity: 'critical',
        description: 'Potential data exfiltration attempt'
      });
    }
    
    return {
      userId,
      anomalies,
      riskScore: this.calculateRiskScore(anomalies),
      timestamp: new Date().toISOString()
    };
  }

  private static detectBruteForce(events: SecurityEvent[]): boolean {
    const failedLogins = events.filter(e => 
      e.category === 'authentication' && e.details.status === 'failed'
    );
    
    return failedLogins.length > 5; // –ë–æ–ª–µ–µ 5 –Ω–µ—É–¥–∞—á–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫
  }

  private static detectUnusualLocation(events: SecurityEvent[]): boolean {
    const locations = events.map(e => e.details.location).filter(Boolean);
    const uniqueLocations = new Set(locations);
    
    return uniqueLocations.size > 3; // –ë–æ–ª–µ–µ 3 —Ä–∞–∑–Ω—ã—Ö –ª–æ–∫–∞—Ü–∏–π
  }

  private static detectDataExfiltration(events: SecurityEvent[]): boolean {
    const dataAccess = events.filter(e => 
      e.category === 'data_access' && e.details.amount > 1000
    );
    
    return dataAccess.length > 10; // –ë–æ–ª–µ–µ 10 –±–æ–ª—å—à–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–∞–Ω–Ω—ã—Ö
  }
}
```

### **2. Automated Response (SOAR)**

#### **Incident Response Automation**
```typescript
// src/lib/security/soar.ts
export class SecuritySOAR {
  static async handleSecurityIncident(incident: SecurityIncident): Promise<void> {
    const response = await this.analyzeIncident(incident);
    
    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –∏–Ω—Ü–∏–¥–µ–Ω—Ç–∞
    switch (incident.type) {
      case 'brute_force':
        await this.handleBruteForce(incident);
        break;
      case 'suspicious_activity':
        await this.handleSuspiciousActivity(incident);
        break;
      case 'data_breach':
        await this.handleDataBreach(incident);
        break;
      case 'malware_detection':
        await this.handleMalware(incident);
        break;
    }
    
    // –£–≤–µ–¥–æ–º–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    await this.notifySecurityTeam(incident, response);
  }

  private static async handleBruteForce(incident: SecurityIncident): Promise<void> {
    // –ë–ª–æ–∫–∏—Ä—É–µ–º IP
    await redis.setex(`blocked:${incident.ip}`, 3600, 'brute_force');
    
    // –¢—Ä–µ–±—É–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
    await this.requireAdditionalAuth(incident.userId);
    
    // –õ–æ–≥–∏—Ä—É–µ–º —Å–æ–±—ã—Ç–∏–µ
    await SecuritySIEM.logSecurityEvent({
      category: 'incident_response',
      severity: 'high',
      details: {
        action: 'ip_blocked',
        reason: 'brute_force',
        ip: incident.ip
      }
    });
  }

  private static async handleDataBreach(incident: SecurityIncident): Promise<void> {
    // –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –±–ª–æ–∫–∏—Ä—É–µ–º –¥–æ—Å—Ç—É–ø
    await this.blockUserAccess(incident.userId);
    
    // –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    await this.notifyUser(incident.userId, 'security_breach');
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º —Ä–∞—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ
    await this.startInvestigation(incident);
    
    // –£–≤–µ–¥–æ–º–ª—è–µ–º —Ä–µ–≥—É–ª—è—Ç–æ—Ä–æ–≤ (–µ—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è)
    if (incident.severity === 'critical') {
      await this.notifyRegulators(incident);
    }
  }
}
```

---

## üìä –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞–º

### **1. ISO 27001 Compliance**

#### **Security Controls Implementation**
```typescript
// src/lib/security/compliance.ts
export class ComplianceManager {
  static readonly securityControls = {
    // A.9 - Access Control
    accessControl: {
      userAccessManagement: true,
      privilegedAccessManagement: true,
      accessReview: true,
      passwordPolicy: true
    },
    
    // A.10 - Cryptography
    cryptography: {
      encryptionAtRest: true,
      encryptionInTransit: true,
      keyManagement: true,
      digitalSignatures: true
    },
    
    // A.12 - Operations Security
    operationsSecurity: {
      changeManagement: true,
      capacityManagement: true,
      separationOfEnvironments: true,
      backupManagement: true
    },
    
    // A.13 - Communications Security
    communicationsSecurity: {
      networkSecurity: true,
      secureTransmission: true,
      messageSecurity: true
    },
    
    // A.14 - System Acquisition
    systemAcquisition: {
      secureDevelopment: true,
      securityTesting: true,
      secureConfiguration: true
    }
  };

  static async generateComplianceReport(): Promise<ComplianceReport> {
    const report = {
      timestamp: new Date().toISOString(),
      standard: 'ISO 27001:2022',
      controls: {},
      overallScore: 0,
      recommendations: []
    };

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å
    for (const [category, controls] of Object.entries(this.securityControls)) {
      report.controls[category] = {};
      
      for (const [control, implemented] of Object.entries(controls)) {
        const status = await this.checkControlStatus(category, control);
        report.controls[category][control] = {
          implemented,
          status,
          evidence: await this.getControlEvidence(category, control)
        };
      }
    }

    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—â–∏–π –±–∞–ª–ª
    report.overallScore = this.calculateComplianceScore(report.controls);
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
    report.recommendations = await this.generateRecommendations(report.controls);

    return report;
  }
}
```

### **2. 152-–§–ó Compliance**

#### **Personal Data Protection**
```typescript
// src/lib/security/personal-data.ts
export class PersonalDataProtection {
  static async processPersonalData(
    data: PersonalData, 
    purpose: DataProcessingPurpose
  ): Promise<ProcessingResult> {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–æ–≤—ã–µ –æ—Å–Ω–æ–≤–∞–Ω–∏—è
    const legalBasis = await this.validateLegalBasis(data, purpose);
    if (!legalBasis.valid) {
      throw new Error('No legal basis for processing');
    }

    // –ü–æ–ª—É—á–∞–µ–º —Å–æ–≥–ª–∞—Å–∏–µ (–µ—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è)
    if (purpose.requiresConsent) {
      const consent = await this.getUserConsent(data.subjectId, purpose);
      if (!consent.valid) {
        throw new Error('No valid consent');
      }
    }

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å —É—á–µ—Ç–æ–º –ø—Ä–∏–Ω—Ü–∏–ø–æ–≤
    const processedData = await this.processWithPrinciples(data, purpose);

    // –õ–æ–≥–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É
    await this.logDataProcessing({
      subjectId: data.subjectId,
      purpose: purpose.name,
      legalBasis: legalBasis.type,
      timestamp: new Date().toISOString()
    });

    return {
      success: true,
      processedData,
      retentionPeriod: purpose.retentionPeriod
    };
  }

  static async handleDataSubjectRequest(
    request: DataSubjectRequest
  ): Promise<DataSubjectResponse> {
    switch (request.type) {
      case 'access':
        return await this.provideDataAccess(request);
      case 'rectification':
        return await this.rectifyData(request);
      case 'erasure':
        return await this.eraseData(request);
      case 'portability':
        return await this.provideDataPortability(request);
      case 'restriction':
        return await this.restrictProcessing(request);
    }
  }

  private static async validateLegalBasis(
    data: PersonalData, 
    purpose: DataProcessingPurpose
  ): Promise<LegalBasisValidation> {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ 152-–§–ó
    const legalBases = [
      'consent',
      'contract',
      'legal_obligation',
      'vital_interests',
      'public_task',
      'legitimate_interests'
    ];

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ–¥—Ö–æ–¥—è—â–µ–µ –ø—Ä–∞–≤–æ–≤–æ–µ –æ—Å–Ω–æ–≤–∞–Ω–∏–µ
    const basis = await this.determineLegalBasis(data, purpose);
    
    return {
      valid: legalBases.includes(basis),
      type: basis,
      evidence: await this.getLegalBasisEvidence(basis)
    };
  }
}
```

---

## üö® Incident Response Plan

### **1. Incident Classification**

```typescript
// src/lib/security/incident-response.ts
export enum IncidentSeverity {
  LOW = 'low',           // –ù–µ–∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è
  MEDIUM = 'medium',     // –£–º–µ—Ä–µ–Ω–Ω—ã–µ —É–≥—Ä–æ–∑—ã
  HIGH = 'high',         // –°–µ—Ä—å–µ–∑–Ω—ã–µ –∏–Ω—Ü–∏–¥–µ–Ω—Ç—ã
  CRITICAL = 'critical'  // –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —É–≥—Ä–æ–∑—ã
}

export enum IncidentType {
  DATA_BREACH = 'data_breach',
  MALWARE = 'malware',
  BRUTE_FORCE = 'brute_force',
  PHISHING = 'phishing',
  INSIDER_THREAT = 'insider_threat',
  DDoS = 'ddos',
  UNAUTHORIZED_ACCESS = 'unauthorized_access'
}

export class IncidentResponse {
  static async handleIncident(incident: SecurityIncident): Promise<void> {
    // 1. –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ–µ —Ä–µ–∞–≥–∏—Ä–æ–≤–∞–Ω–∏–µ (0-15 –º–∏–Ω—É—Ç)
    await this.immediateResponse(incident);
    
    // 2. –°–¥–µ—Ä–∂–∏–≤–∞–Ω–∏–µ (15-60 –º–∏–Ω—É—Ç)
    await this.containment(incident);
    
    // 3. –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ (1-24 —á–∞—Å–∞)
    await this.eradication(incident);
    
    // 4. –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ (24-72 —á–∞—Å–∞)
    await this.recovery(incident);
    
    // 5. –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —É—Ä–æ–∫–æ–≤ (1-2 –Ω–µ–¥–µ–ª–∏)
    await this.lessonsLearned(incident);
  }

  private static async immediateResponse(incident: SecurityIncident): Promise<void> {
    // –ë–ª–æ–∫–∏—Ä—É–µ–º —É–≥—Ä–æ–∑—É
    if (incident.severity >= IncidentSeverity.HIGH) {
      await this.emergencyShutdown(incident);
    }
    
    // –£–≤–µ–¥–æ–º–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É
    await this.notifySecurityTeam(incident);
    
    // –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É–µ–º –∏–Ω—Ü–∏–¥–µ–Ω—Ç
    await this.documentIncident(incident);
  }
}
```

---

## üìã Security Checklist

### **Pre-deployment Security Checklist**

- [ ] **–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è**
  - [ ] MFA –≤–∫–ª—é—á–µ–Ω–∞ –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
  - [ ] OAuth 2.1 + OIDC –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã
  - [ ] JWT —Ç–æ–∫–µ–Ω—ã —Å –∫–æ—Ä–æ—Ç–∫–∏–º TTL
  - [ ] –ü—Ä–∏–Ω—Ü–∏–ø –º–∏–Ω–∏–º–∞–ª—å–Ω—ã—Ö –ø—Ä–∏–≤–∏–ª–µ–≥–∏–π

- [ ] **–ó–∞—â–∏—Ç–∞ –¥–∞–Ω–Ω—ã—Ö**
  - [ ] –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ at rest (AES-256-GCM)
  - [ ] –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ in transit (TLS 1.3)
  - [ ] –ê–Ω–æ–Ω–∏–º–∏–∑–∞—Ü–∏—è –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
  - [ ] –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ 152-–§–ó

- [ ] **–ó–∞—â–∏—Ç–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è**
  - [ ] Input validation –∏ sanitization
  - [ ] Rate limiting –Ω–∞—Å—Ç—Ä–æ–µ–Ω
  - [ ] WAF –∑–∞—â–∏—Ç–∞ –∞–∫—Ç–∏–≤–Ω–∞
  - [ ] SAST/DAST —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–π–¥–µ–Ω–æ

- [ ] **–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ**
  - [ ] SIEM —Å–∏—Å—Ç–µ–º–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞
  - [ ] Security events –ª–æ–≥–∏—Ä—É—é—Ç—Å—è
  - [ ] Anomaly detection –∞–∫—Ç–∏–≤–µ–Ω
  - [ ] Incident response –ø–ª–∞–Ω –≥–æ—Ç–æ–≤

- [ ] **–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞–º**
  - [ ] ISO 27001 controls –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã
  - [ ] 152-–§–ó compliance –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω
  - [ ] Security audit –ø—Ä–æ–π–¥–µ–Ω
  - [ ] Penetration testing –≤—ã–ø–æ–ª–Ω–µ–Ω

---

## üéØ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–î–∞–Ω–Ω–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç:

- ‚úÖ **–°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏** 2025 –≥–æ–¥–∞
- ‚úÖ **Zero Trust –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞** —Å –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–æ–π –∑–∞—â–∏—Ç–æ–π
- ‚úÖ **–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ä–æ—Å—Å–∏–π—Å–∫–æ–º—É –∑–∞–∫–æ–Ω–æ–¥–∞—Ç–µ–ª—å—Å—Ç–≤—É** (152-–§–ó)
- ‚úÖ **–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥** –∏ —Ä–µ–∞–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
- ‚úÖ **Compliance —Å –º–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã–º–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞–º–∏** (ISO 27001)

**–°–ª–µ–¥—É—é—â–∏–π —à–∞–≥**: –í–Ω–µ–¥—Ä–µ–Ω–∏–µ security controls –∏ –ø—Ä–æ–≤–µ–¥–µ–Ω–∏–µ security audit! üîí

---

*–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–æ: 16 –æ–∫—Ç—è–±—Ä—è 2025*  
*–í–µ—Ä—Å–∏—è: 1.0*  
*–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞–º: ISO 27001:2022, 152-–§–ó ‚úÖ*
